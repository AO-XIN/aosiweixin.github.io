

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/icon/IMG_0896%20%281%29.png">
  <link rel="icon" type="image/png" href="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/icon/IMG_0896%20%281%29.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="max">
  <meta name="keywords" content="">
  <title>Notebook|CNetNotebook||计算机网络自顶向下方法笔记 - Aoxin Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.auswitz.top","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Aoxin`s Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://pic.downk.cc/item/5ff6ec6a3ffa7d37b3561203.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Notebook|CNetNotebook||计算机网络自顶向下方法笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-03-01 20:45" pubdate>
        2023年3月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      31.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      338
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Notebook|CNetNotebook||计算机网络自顶向下方法笔记</h1>
            
            <div class="markdown-body">
              <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><blockquote>
<p>按照《计算机网络自顶向下》的目录整理的相关笔记</p>
<p>和之前比更新了很多东西，也删除了很多模糊或者不算重要的知识点。除了第一章整理的还不算清楚之外，其他的都应该清楚了。</p>
</blockquote>
<h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1. 计算机网络"></a>1. 计算机网络</h1><p>构成因特网的软件和硬件，根据分布式应用提供服务的联网基础设施来描述因特网</p>
<blockquote>
<p>世界范围内的计算机网络 因特网就是将端系统彼此互联</p>
</blockquote>
<h2 id="1-1-具体构成和描述"><a href="#1-1-具体构成和描述" class="headerlink" title="1.1 具体构成和描述"></a>1.1 具体构成和描述</h2><h3 id="端系统，分组Packet"><a href="#端系统，分组Packet" class="headerlink" title="端系统，分组Packet"></a>端系统，分组Packet</h3><ul>
<li>所有连接的设备，叫做主机或者端系统 HOST END SYSTEM</li>
<li>端系统通过通信链路communication link和分组交换机连接在一起</li>
<li>通信链路又不同类型的物理媒介组成，链路的传输速率为 BIT/S bps 比特每秒来计算</li>
<li>分组Packet，发送端将数据分段并为每段加上首部字母，这样的信息包叫做分组</li>
</ul>
<h3 id="分组交换机"><a href="#分组交换机" class="headerlink" title="分组交换机"></a>分组交换机</h3><ul>
<li>分组交换机，从交换机的一条入链路将分组转发并从出通信链路发出</li>
<li>分组交换机包括，路由器Router，链路层交换机Link-layer switch</li>
<li>链路层交换机用于接入网，路由器用于核心网</li>
</ul>
<h3 id="通信链路"><a href="#通信链路" class="headerlink" title="通信链路"></a>通信链路</h3><ul>
<li>从发送端到接收端系统，一个分组所经历的一系列的通信链路和分组交换机称为通过该网络的路径，Path Route</li>
<li>分组类似于运载货物的卡车，通信链路类似于公路，分组交换机类似于立交桥；</li>
<li>链路的速率，主要取决于分组交换机的转发能力： RM bps表示路由器在1S内可以完成R兆bit的转发</li>
</ul>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul>
<li>端系统由 ISP internet service provider 接入因特网</li>
<li>每个ISP是一个由多个分组交换机和多段通信链路组成的网络，各ISP为端系统提供了各种不同类型的网络接入</li>
<li>底层ISP通过国际的高层ISP互联，独立管理，运行着IP协议</li>
<li>调制解调？</li>
</ul>
<h3 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 Protocol"></a>协议 Protocol</h3><ul>
<li><p>协议控制着网络中或因特网中的信息接受和发送，TCP和IP协议是最重要的两个协议，主协议统称为TCP/IP</p>
</li>
<li><p>TCP Transmission Control Protocol 控制传输协议</p>
</li>
<li><p>IP Internet Protocol 网际协议，IP协议定义了在路由器和端系统之间发送和接受的分组格式</p>
</li>
<li><p>背景，Internet Standard 由 InternetEngineering Task Force研发，其他组织也会制定标准，例如以太网标准，Wi-Fi标准</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-20210711134244371.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="20210711134244371"></p>
</li>
</ul>
<h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul>
<li>应用程序提供服务的基础设施：分布式应用程序 distributed application，application运行在端系统上，分组交换机并不关心作为数据源或者宿的应用程序</li>
<li>端系统提供应用程序编程接口，API，API规定了运行在一个端系统上的软件向另一个端系统的特定目的地软件交付数据的方式</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li>因特网中涉及两个或者多个远程通信的实体活动都受到协议的制约，交换报文或者采取动作的实体是硬件或者软件</li>
<li>硬件实现的协议控制了在两块“接口卡”之间的“线上”比特流</li>
<li>端系统中，拥塞控制协议控制了发送方和接受方之间传输的分组Packet发送频率</li>
<li><strong>一个协议定义了两个或者多个通信实体之间的交换的报文格式和次序，以及报文发送和接受所采取的动作（一系列约定俗成的动作）</strong>；</li>
<li>构成，原理，工作方式；</li>
</ul>
<h2 id="1-2-网络边缘-边缘计算"><a href="#1-2-网络边缘-边缘计算" class="headerlink" title="1.2 网络边缘 - 边缘计算"></a>1.2 网络边缘 - 边缘计算</h2><ul>
<li>在因特网中处于边缘的系统，叫做端系统；</li>
<li><strong>主机 = 端系统 HOST = END SYSTEM</strong> ，主机被划分为两类：Clinet和Server。web服务器属于大型的数据中心Data Center，client通常为桌面级pc和手机等，server为更为强大的服务器</li>
</ul>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ul>
<li><p>端系统和应用程序位于网络边缘，access network，接入网是将端系统接到其边缘路由器的物理链路（edge router）- 端系统接入边缘路由的链路</p>
</li>
<li><p>边缘路由器，<strong>是端系统到其他任何远程端系统路径上的第一台路由器</strong></p>
<blockquote>
<p>端系统 —(A)— 边缘路由（第一台路由） A:这样的一条链路称为接入网</p>
</blockquote>
</li>
<li><p>上下行速率由编码频率控制，频率越高，速度越高，家庭DSL，家庭接入同轴电缆</p>
</li>
<li><p>调制解调为外部设备</p>
</li>
<li><p>物理链路的搭建方式 </p>
</li>
</ul>
<h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><ul>
<li>数字用户线和电缆</li>
</ul>
<h3 id="以太网和wifi"><a href="#以太网和wifi" class="headerlink" title="以太网和wifi"></a>以太网和wifi</h3><ul>
<li>局域网将端系统连接到边缘路由，以太网为接入技术</li>
</ul>
<h3 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h3><ul>
<li>5G</li>
</ul>
<h3 id="物理媒介"><a href="#物理媒介" class="headerlink" title="物理媒介"></a>物理媒介</h3><ul>
<li>通过跨越物理媒介 Physical Medium传播电磁波活着光脉冲来发送bit；</li>
<li>物理媒介：引导型媒介，电磁波沿着物理媒介前进；非引导型媒介，电磁波沿着空气前进</li>
<li>双绞铜线、同轴电缆、光纤等</li>
</ul>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><ul>
<li>网络核心：<strong>由互联因特网端系统的分组交换机和链路构成的网状网络</strong>；</li>
<li><strong>分组交换机包括路由和链路层交换机</strong>；</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul>
<li><p>端系统彼此交换报文（message），报文包含了协议设计者需要的所有的东西；</p>
</li>
<li><p>源端系统向目的端系统发送一个报文，“源”将长报文划分为较小的数组快，为“分组”Packet；</p>
</li>
<li><p>在源和目的之间，每个分组都通过通信链路的分组交换机（packet swith）传送；路由器和链路层交换机</p>
</li>
<li><p>每个分组以等于该链路最大传输速率的速度传输通过通信链路</p>
</li>
<li><p>一个Lbit的分组，链路速率为Rbit/s，则传输时间为L/R s</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230227175614947.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230227175614947"></p>
</li>
</ul>
<h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul>
<li>指交换机在开始向输出链路传输该分组的第一个bit前，必须已经接收到了整个分组；缓存分组比特，当路由器由输入链路接收完了整个分组后（此时花费L/R的时间），才开始向出链路传输（传输完成需要花费L/R），总延时为2L/R s</li>
<li>N条速录为R的链路，转发一个分组，d源到端 = N L/R</li>
</ul>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><ul>
<li>每个分组交换机与多条线路相连，分组交换机有一个输出缓存，output buffer，output Queue；到达的分组的传输链路处于繁忙状态，传输其他分组，达分组会在“输出缓存”中等待；</li>
<li>时延，1. 存储转发时延，2. 排队时延，时延处于变化的状态，变化程度取决于网络中的拥塞程度</li>
<li>丢包，一个分组发现“输出缓存”已经被其他的等到传输的分组完成充满了，这时就会出现“分组丢包”，Packet lost，到达分组或者已经排队的分组之一会被丢弃；</li>
<li>分组达到率（每秒比特）超过了输出链路的速率，这些分组在通过链路传输前，在“链路输出缓存中排队”，在该路由器中将出现拥塞；</li>
</ul>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><ul>
<li>因特网中，每个端系统具有IP地址，源向目的端发送分组，分组的首部都包含了IP地址；</li>
<li>路由器具有转发表，forwarding table，用于将目的地址（或者地址中的几段）映射为输出链路；</li>
<li>分组到达路由器，路由器检查分组地址，并用目的地址搜索转发表，发现出链路，则将该分组导向出链路；</li>
<li>转发表配置问题，路由选择协议 routing protocol，用于自动设置转发表；</li>
</ul>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul>
<li>网络链路和交换机转发数据的两种基本方式：1. 电路交换 2. 分组交换；</li>
<li>电路交换需要提前预留报文要使用的资源，缓存链路传输速率等，传统的电话就是一种电路交换，连接期间预留了恒定的传输速率；</li>
<li>实现方式：频分复用 Frequency-Division Multiplexing， 时分复用Time-Division Multiplexing；</li>
<li>带宽 bandwidth：频段的宽度 80——100Mhz；</li>
<li>相关计算在P21</li>
</ul>
<h3 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h3><ul>
<li><p>分组交换的性能优于电路交换；</p>
<blockquote>
<p>例子：假设10个用户，某个用户产生1000个1000bit的分组，其他用户保持静默。每帧具有10个间隙且每个间隙保护1000bit的TDM电路交换情况下，活跃用户只能使用每帧中的一个间隙来传输数据，传完1000，000的bit数据需要10S时间，而分组交换的情况下，活跃用户能连续的以1Mbps的速率使用链路，完成数据的发送只需要1S；</p>
</blockquote>
</li>
<li><p>电路交换需要预先分配传输链路，使得已分配但是不需要的链路时间未被使用；分组交换按需分配链路使用，链路传世能力在所有用户之间逐分组共享；</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分组交换</td>
<td>① 加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。② 简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。③ 减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。④ 由于分组短小，更适用于采用优先级策略。</td>
<td>① 尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。② 分组交换中的每个分组都要加上源、目的地址和分组编号等信息，这将增大传送的信息量，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。③ 当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</td>
</tr>
<tr>
<td>电路交换</td>
<td>① 由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。② 通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。③ 双方通信时按发送顺序传送数据，不存在失序问题。④ 电路交换既适用于传输模拟信号，也适用于传输数字信号。⑤ 电路交换设备控制均较简单。</td>
<td>① 电路交换的平均连接建立时间对计算机通信来说偏长。② 电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。③ 电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h3><ul>
<li>十多个第一层ISP和数十万个底层ISP组成，ISP覆盖大洲，大洋，有些覆盖小的地理区域；底层与高层互联，高层彼此互联；</li>
</ul>
<h2 id="1-4-分组交换网中的时延、丢包、吞吐量"><a href="#1-4-分组交换网中的时延、丢包、吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包、吞吐量"></a>1.4 分组交换网中的时延、丢包、吞吐量</h2><ul>
<li><p>时延：节点处理时延，排队时延，传输时延，传播时延，节点总时延；</p>
</li>
<li><p>处理时延，检查分组首部需要的处理时延，用来决定将该分组导向何处</p>
</li>
<li><p>排队时延，分组在链路上等待传输是排队的时延（“输出缓存” output buffer）</p>
</li>
<li><p>传输时延/发送时延，<strong>数据长度/信道带宽</strong> 先到先服务，仅当所有已到达分组被传输后，才能传输刚到达的分组，链路速率R bps，R个bit每秒，时延=分组比特/链路速率，毫秒微秒量级</p>
</li>
<li><p>传播时延，<strong>信道长度/传播速率</strong>，是分组从一个路由器传输到另一个路由器，所在的链路的传播需要的时间，它和链路的物理长度及物理媒介有关，和链路的速率以及分组长度无关；</p>
</li>
<li><p>区别：传输时延是由路由器将整个分组推出所需要的时间，这里的速率完全取决于路由器的转发能力，R Mbps表示路由器在1S内可以完成R兆bit的转发，速率也和编码频率有关； 传播时延表示分组或者数据比特在物理或者媒介中传播所需要的时间；</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228151743340.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230228151743340"></p>
</li>
</ul>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><ul>
<li>排队时延取决于流量到达该队列的速率，链路传输的速率和流量到达的性质；</li>
<li>R表示链路的传输速率，就是从队列中推出bit的速率 bps</li>
<li>假设a表示分组达到队列的速率，L表示分组的比特数量，则La bps表示比特到达队列的平均速率，La/R为 流量强度 traffic intensity； 流量强度不能大于 1</li>
</ul>
<h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><ul>
<li>随着”流量强度” 接近1，分组交换机或路由器将会对已经满了的队列，丢弃新的分组，Drop，该分组将会丢失Lost；</li>
<li>一个结点的性能是根据分组的丢失概率来度量的；</li>
</ul>
<h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><ul>
<li>N-1台路由器 总时延 = N （主机和路由器上的处理时延 + 链路传播时延 + 传输时延L/R</li>
<li>traceroute软件做时延分析</li>
</ul>
<h3 id="端系统、应用程序、其他时延"><a href="#端系统、应用程序、其他时延" class="headerlink" title="端系统、应用程序、其他时延"></a>端系统、应用程序、其他时延</h3><ul>
<li>对于某些协议，端系统application处理的延时；</li>
</ul>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul>
<li><strong>单位时间通过某个接口的数据量</strong></li>
<li>瞬时吞吐量：端系统接受到该文件的速率 bps，例如下载文件的的速率显示</li>
<li>平均吞吐量：F比特的文件，主机接收到所以的bit用了T秒时间，平均吞吐量为F/T</li>
<li>有些Application中吞吐量比时延更重要；</li>
<li>Rs表示服务器与路由器之间的链路速率，Rc表示路由器和客户端之间的链路速率，对于Server来说他的吞入量为min{Rs, Rc}，这里的吞入量为瓶颈链路速率，bottleneck link，当然这里的吞吐量还需要考虑分组层次和传输协议的问题；</li>
<li>吞吐量取决于数据流过链路的传输速率；在没有其他条件干扰时，吞吐量近似等于源和目的之间的最小传输速率；</li>
</ul>
<h3 id="bandwidth-带宽"><a href="#bandwidth-带宽" class="headerlink" title="bandwidth 带宽"></a>bandwidth 带宽</h3><ul>
<li><p><strong>网络设备所能支持的最高速度</strong>，理想的极限传输速率</p>
</li>
<li><p>Bandwidth (signal processing) or analog bandwidth, frequency bandwidth or radio bandwidth, a measure of the width of a range of frequencies, measured in hertz</p>
</li>
<li><p>Bandwidth (computing), the rate of data transfer, bit rate or throughput, measured in bits per second (bit/s)</p>
</li>
<li><p>Spectral linewidth, the width of an atomic or molecular spectral line, measured in hertz</p>
</li>
<li><p>对于信号处理中，bandwidth表示当前信号的频段宽度，例如模拟信号或者数字信号的”频率范围“ hz为单位</p>
</li>
<li><p>对于计算机网路链路，带宽为当前最大传输速率，没秒钟链路能够传输或处理的比特，bit/s为单位，注意在电路交换中带宽表示的是频率范围；</p>
</li>
</ul>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul>
<li>*<em>时延带宽积(bit)=传播时延(s)<em>带宽(bit/s)</em></em></li>
<li>时延带宽积是描述一个链路中，此时此刻的bit数量<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3></li>
<li>从发送方发送数据开始，到发送方收到接收方的确认（接收方收到后立即发送确认），总共经历的时延</li>
<li>RTT包括：*<em>2</em>传播时延、末端处理时间**<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3></li>
<li>信道利用率=有数据通过时间/总共时间</li>
<li>网络利用率=信道利用率加权平均值</li>
<li><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228152734030.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230228152734030"><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2></li>
</ul>
<h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><ul>
<li>网络以分层的方式组织协议，某层会向上一层提供服务，就是服务模型；</li>
<li>应用层协议在端系统中以软件方式实现，物理层和数据链路层则复杂处理跨越链路的通信，通常实现在给定的接口卡中；网络层则有软硬件的混合；</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul>
<li>各层所有的协议被称为协议栈 protocol stack</li>
<li>因特网的协议栈由5层组成 <strong>1. 物理层 2. 数据链路层 3. 网络层 4. 传输层 5. 应用层</strong></li>
<li><strong>应用层</strong>：<strong>用户与网络的界面</strong>，网络应用程序之间定义的协议留存的分层，分布在多个端系统上，一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，位于应用层的信息分组称为报文（message）<strong>FTP、SMTP、HTTP</strong></li>
<li>表示层：数据格式的变换、数据的解密加密、数据的压缩和恢复</li>
<li>会话层：像表示层提供建立连接并且有序的传输数据</li>
<li><strong>传输层</strong>、运输层：用于传输应用层报文，主要有TCP和UDP，TCP向他的应用程序提供了面向连接的服务。TCP也将长报文划分为短报文，提供拥塞机制；TCP源代码；UDP无连接，不提供服务的服务，运输分组可以称为<strong>报文段 segment</strong>，端到端的通信。<strong>可靠传输、差错控制、流量控制、复用分用功能</strong>   主要协议： <strong>TCP、UDP</strong></li>
<li><strong>网络层</strong>：分组单位是<strong>数据报 datagram</strong>，将数据报 datagram 的网络层分组从一台主机移动到另一台主机；源主机中TCP或者UDP运输协议向网络层递交运输层报文段segment和目的地址，网络层IP协议定义了数据报中的各个字段和端系统及路由器如何作用这些字段，IP协议和路由选择协议，IP协议连接了硬件和软件层；</li>
<li><strong>数据链路层</strong>：分组单位是<strong>帧 Frame</strong>，网络层从源到目的之间经过路由器路由数据报，将分组从一个结点移动到另一个结点，必须“依靠数据链路层的服务”，网络层将数据报下传给链路层，链路层沿着链路将数据传递给下个结点，下个结点链路层又将数据报上报给了网络层；链路层提供的服务取决于链路层的协议。链路层的分组为”帧“Frame，以太网，Wi-Fi，DOCsis；</li>
<li><strong>物理层</strong>：<strong>在物理媒体上实现比特流的传输</strong>，物理层的任务是将链路层中的帧中的一个一个bit从一个结点移动到下一个结点，物理层协议于链路相关，也与物理介质相关，例如同轴电缆卡，光纤；</li>
</ul>
<h3 id="OSI、TCP-IP与五层参考模型"><a href="#OSI、TCP-IP与五层参考模型" class="headerlink" title="OSI、TCP/IP与五层参考模型"></a>OSI、TCP/IP与五层参考模型</h3><ul>
<li><p>ISO国际标准化组织提出OSI，开发系统互联模型，理论模型，服务、协议、接口。</p>
</li>
<li><p>与之相对的TCP/IP参考模型有四层</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228144700581.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230228144700581"></p>
</li>
<li><p>应用层 表示层 会话层 传输层 网络层 链路层 物理层</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-1-1Z1241445324H.jpg?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="OSI 七层网络模型和 TCP/IP 四层网络模型的对比"></p>
<ul>
<li>五层参考模型</li>
</ul>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228145106620.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230228145106620"></p>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>应用层 报文 mesasge 传输层 报文段 segment = message + header 网络层 数据报 datagram = segment + header<br>链路层 帧 frame = datagram + header 物理层</p>
</blockquote>
<ul>
<li>application-layer message — transport-layer segment — network-layer datagram — link-layer frame</li>
<li>链路层交换机实现第一层和第二层，路由器实现第一层到第三层，路由器能够实现IP协议，链路交换机不能，链路层交换机能够实现第二层地址，以太网地址；网络边缘的端系统可以实现一到五层，将复杂性较高的结构放在边缘；</li>
<li>封装 （encapsulation）：在发送端，一个应用层报文（application-layer message） — 应用层报文+传输层首部=运输层报文段（transport-layer segment） — 网络层增加了源和目的端地址等网络数据报的首部，产生了网络层数据报 — 链路层增加链路层首部信息并创建链路层帧</li>
<li>每个分层：首部字段+有效载荷字段（header + payload field），有效载荷为上一层分组</li>
</ul>
<h2 id="1-6-攻击的网络"><a href="#1-6-攻击的网络" class="headerlink" title="1.6 攻击的网络"></a>1.6 攻击的网络</h2><h2 id="1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展"><a href="#1-7-历史，分组交换的发展，专用网络和互联网络，因特网的发展" class="headerlink" title="1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展"></a>1.7 历史，分组交换的发展，专用网络和互联网络，因特网的发展</h2><hr>
<hr>
<h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-网路应用程序体系结构"><a href="#2-1-网路应用程序体系结构" class="headerlink" title="2.1 网路应用程序体系结构"></a>2.1 网路应用程序体系结构</h2><ul>
<li>客户 - 服务器体系结构 client-server architecture 如Web应用，客户之间并不直接通信</li>
<li>P2P结构， per to per architecture，对于服务器有最小依赖，“对等方”在主机间直接通信，p2p特性，自扩展性；</li>
</ul>
<h3 id="2-1-1进程通信"><a href="#2-1-1进程通信" class="headerlink" title="2.1.1进程通信"></a>2.1.1进程通信</h3><ul>
<li>进行通信的实际是进程</li>
<li>运行在不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信；</li>
<li>进程通过<strong>“套接字” socket的软件接口</strong>向网络发送报文和从网络接受报文，Socket下面使用运输层TCP或UDP协议，套接字也称为“网络程序编程接口”，套接字对运输层仅仅能 1.选择运输层协议 2.设定运输层参数如最大缓存，最大报文长度等。<strong>套接字是应用层和运输层之间的接口</strong></li>
<li>开发者选择了运输层协议，应用程序就建立在由该协议提供的运输层服务至上；</li>
<li>进程寻址，“IP地址”来标识主机地址，“端口号Port”来表示主机中的进程，从而定位到通信的进程；</li>
</ul>
<h3 id="2-1-2可供应用程序使用的运输服务"><a href="#2-1-2可供应用程序使用的运输服务" class="headerlink" title="2.1.2可供应用程序使用的运输服务"></a>2.1.2可供应用程序使用的运输服务</h3><ul>
<li><strong>可靠数据传输</strong>：分组交换机的缓存溢出导致的分组丢失，可靠数据传输（reliable data transfer），运输层协议向应用程序提供进程到进程的可靠数据传输</li>
<li><strong>吞吐量</strong>：两个进程之间，可用吞吐量就是发送进程到接收进程交付比特的速率，会话会共享沿着网络路径的带宽，可用吞吐量会随着时间波动，运输层协议能够以某种特定的速率提供确保的可用吞吐量；具有吞吐量要求的应用程序为”宽铭感应用”，“弹性应用”是或多或少的利用可用吞吐量；</li>
<li><strong>定时</strong>：运输层协议保障提供数据传输的总时延小于一个特定值；</li>
<li><strong>安全性</strong>：运输层协议保障加密进程发送的数据</li>
</ul>
<h3 id="2-1-3运输服务"><a href="#2-1-3运输服务" class="headerlink" title="2.1.3运输服务"></a>2.1.3运输服务</h3><ul>
<li>TCP/IP网络中两个运输层协议，TCP和UDP</li>
</ul>
<h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul>
<li>TCP服务模型包括<strong>面向连接服务和可靠数据传输服务</strong></li>
<li>面向连接服务：连接的三次握手，握手完成后，TCP连接就在两个进程的套接字之间建立了。四次分手</li>
<li>可靠的数据传输服务：TCP，会无差错、按照顺序交付所发送的数据，当App的一端将字节流传进套接字是，能够依靠TCP将相同的字节流交付给接收方的套接字，没有字节的丢失和冗余；</li>
<li><strong>拥塞控制机制，在网络发送拥塞时，TCP的拥塞控制机制会抑制发送进程；或使每个连接达到公平共享带宽的目的；</strong></li>
<li>TCP UDP 不提供任何加密机制，安全套接字，SSL secure sockets layer；SSL是对TCP运输协议的加强，这样的<strong>安全强化是在应用层实现的（很容易）</strong>；SSL有独立的一套SOCKET API</li>
</ul>
<h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul>
<li>轻量级运输协议，提供最小服务，UDP是无连接的，提供一种不可靠的数据传输服务；</li>
<li>UDP不保证报文到达接收方进程，到达的数据有可能是乱序到达；</li>
<li><strong>UDP没用拥塞机制，发送端可以使用UDP选定任何速率向下层注入数据；</strong></li>
</ul>
<h4 id="运输协议不提供的服务"><a href="#运输协议不提供的服务" class="headerlink" title="运输协议不提供的服务"></a>运输协议不提供的服务</h4><ul>
<li>不能提供定时和带宽保证；</li>
<li>网络语音，以UDP作为主要运输协议，TCP作为当UDP流量被防火墙阻挡后的备选方案；</li>
</ul>
<h3 id="2-1-4应用层协议"><a href="#2-1-4应用层协议" class="headerlink" title="2.1.4应用层协议"></a>2.1.4应用层协议</h3><ul>
<li>应用层协议定义了</li>
</ul>
<blockquote>
<p>交换的报文类型，如请求报文和响应报文 报文语法 字段含义 进程何时及如何发送报文，报文的响应规则</p>
</blockquote>
<p>HTTP 超文本传输协议，公共域的RFC SMTP 简单邮件传输协议</p>
<h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h3 id="2-2-1HTTP"><a href="#2-2-1HTTP" class="headerlink" title="2.2.1HTTP"></a>2.2.1HTTP</h3><ul>
<li>一个客户程序和一个服务器程序，运行在不同的端系统中，通过交换HTTP报文进行会话；HTTP定义了报文格式，已经报文的交换方式；</li>
<li>术语</li>
</ul>
<blockquote>
<p>Web页面 webpage 对象 object</p>
</blockquote>
<ul>
<li>HTTP定义了web客户端向服务器请求页面的方式；</li>
<li>HTTP使用<strong>TCP</strong>运输层服务，客户向他的套接字发送http报文，并从套接字接收响应报文；</li>
<li>HTTP服务每次发送报文，都会将报文通过套接字交给TCP服务，<strong>HTTP协议不用担心数据的丢失和乱序问题，分层体系结构的最大优点</strong>；</li>
<li>HTTP服务器不保存每次客户访问的信息，是一个“无状态协议“ stateless protocol</li>
</ul>
<h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><ul>
<li>非持续连接：每个请求是经过每次的单独的TCP连接发送，每次发送报文新建TCP连接</li>
<li>持续连接：所有的请求以同一个的TCP连接发送；</li>
<li><strong>HTTP既能使用非持续，也能使用持续连接</strong>，默认方式是使用持续连接，可以配置成非持续</li>
</ul>
<h4 id="非持续连接的HTTP"><a href="#非持续连接的HTTP" class="headerlink" title="非持续连接的HTTP"></a>非持续连接的HTTP</h4><ul>
<li>每个TCP连接只传输一个请求报文和一个响应报文；</li>
<li>往返时间： Round-Trip Time RTT，一个短分组从客服到服务器，再返回客户端所花费的时间；</li>
<li>RTT：分组传播时延，分组传输时延、排队时延、处理时延</li>
<li><strong>三次握手</strong>，客户向服务器发起一个TCP连接，客户向服务器发送一个小的TCP报文段，服务器用一个小TCP段作出确认和响应，最后客户向服务器返回确认（此时客户结合这部分发送一个http请求报文，一旦该报文被服务器接收，服务器就在该TCP连接上发送HTML文件）；</li>
<li><strong>采用非持续连接经受双倍的RTT交付延迟，第一个RTT用于创建TCP，第二个RTT用于请求和接受对象。值得注意的是，三次握手的第三次同时在请求。</strong></li>
</ul>
<h4 id="持续连接的HTTP"><a href="#持续连接的HTTP" class="headerlink" title="持续连接的HTTP"></a>持续连接的HTTP</h4><ul>
<li>非持续中，每个TCP都需要在服务器中分配TCP的缓冲区和保持TCP变量，给服务器带来较大负担，而且每个对象都需要经受两倍的RTT交付时延；一个RTT用来创建TCP连接，一个用来请求和接收对象；</li>
<li>HTTP的默认模式是使用带流水线的持续连接，服务器在发送响应后保持TCP连接打开，同一个客户和服务器的后续请求和响应报文通过相同的TCP连接进行；服务器可以以流水线的方式一个接一个的发出对象的请求，不必等待回答；超时后HTTP服务器就会关闭连接；</li>
</ul>
<h3 id="2-2-2HTTP报文格式"><a href="#2-2-2HTTP报文格式" class="headerlink" title="2.2.2HTTP报文格式"></a>2.2.2HTTP报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul>
<li><p>使用ASCII编写，最少一行，最后一行附加一个换行符；</p>
</li>
<li><ol>
<li>请求行，后续叫做首部行 【方法字段】【URL统一资源定位】【HTTP版本】</li>
</ol>
</li>
</ul>
<ul>
<li>方法字段： GET POST HEAD PUT DELETE</li>
<li>首部行：HOST指明了对象所在主机，Web代理高速缓存所要求的</li>
<li>Connection：close 要求服务器在发送完被请求对象后关闭这条连接</li>
<li>User-agent：用户代理，不同的agent表示不同的设备或者浏览器。Mozilla标准</li>
</ul>
<ul>
<li>绝大部分使用GET方法</li>
<li>POST报文仍然可以向服务器请求对象，表单的请求报文不是必须使用POST方法；</li>
<li>HEAD方法和GET方法类似，但是服务器不返回请求对象；</li>
<li>PUT方法多用于上传路径的服务</li>
<li>DETELE方法允许用户删除服务器上的对象</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li><p>状态行status line，协议版本+状态码+状态信息</p>
</li>
<li><p>首部行 header line</p>
</li>
<li><p><strong>实体行 entity body</strong>   实体部分是报文的主要部分，包含了对象本身；</p>
</li>
<li><p>Connection：close 表示告诉客户，发送完报文后服务器将关闭TCP连接</p>
</li>
<li><p>Date：响应报文的时间</p>
</li>
<li><p>Server：Server类型和版本</p>
</li>
<li><p>Last—Modified：对象的最后修改时间</p>
</li>
<li><p>Content-Length：被发送对象的字节数</p>
</li>
<li><p>Content-Type：内容类型</p>
</li>
<li><p>常见短语和状态码<br><code>200 OK</code>：请求成功</p>
<p><code>301 Moved Permanently</code>：请求的对象被永久转移了</p>
<p><code>400 Bad request </code>：请求不能被服务器理解 </p>
<p><code>404 Not Found</code>：请求的对象不在服务器</p>
<p><code>505 HTTP Version Not Supported</code>服务器不支持请求报文使用的http协议版本</p>
</li>
</ul>
<h3 id="2-2-3cookie"><a href="#2-2-3cookie" class="headerlink" title="2.2.3cookie"></a>2.2.3cookie</h3><ul>
<li><p>HTTP服务是无状态的，cookie允许站点对用户进行跟踪；包含以下四个部分</p>
</li>
<li><ul>
<li>HTTP响应报文中包含一个cookie首部行</li>
<li>HTTP请求报文中的一个cookie首部行</li>
<li>用户系统中保留一个cookie文件</li>
<li>web站点后端数据库</li>
</ul>
</li>
<li><p>Set-cookie首部识别码可以确定一个用户，在站点上每次访问的路径，跟踪用户的活动；</p>
</li>
<li><p><strong>过程：在用户首次访问网站时，网站产生一个唯一识别码并保存在web站点后端数据库，接下来Web服务器把包含该识别码的报文传给用户，用户的浏览器收到报文后，将该识别码记录在浏览器的cookie文件中，这条记录包含服务器的主机名和识别码。当用户后面再次浏览该网站时，用户查询到目标服务器和识别码对应，就将识别码加入到http请求报文中。这样网站就可以跟踪用户的活动。</strong></p>
</li>
</ul>
<h3 id="2-2-4Web缓存"><a href="#2-2-4Web缓存" class="headerlink" title="2.2.4Web缓存"></a>2.2.4Web缓存</h3><ul>
<li>Web cache &amp; proxy server 也叫代理服务器</li>
<li>代表初始的web服务器来满足http请求的网络实体</li>
<li>有自己的磁盘空间用来存储最近保存过的对象的副本</li>
<li><strong>过程：浏览器创建一个到web cache的tcp连接，并向web cache发送HTTP请求，Web缓存对对象做检查，有则直接返回给浏览器，无则与对象的初始服务器建立TCP连接。Web缓存器在这个TCP连接上发送HTTP请求，初始服务器Web cache进行响应，接收到对象的web cache会在本地存储一份副本，并向浏览器发送对象，web cache和浏览器也是TCP连接；</strong></li>
<li>通常由ISP提供，比如一所大学可能在校园网上安装一台WEB缓存器。</li>
<li>内容分发网络 Content Distribution Network CDN，CDN在地理位置上安装了很多缓存器，使得大量流量本地化</li>
</ul>
<h3 id="2-2-5条件GET方法"><a href="#2-2-5条件GET方法" class="headerlink" title="2.2.5条件GET方法"></a>2.2.5条件GET方法</h3><ul>
<li><p><strong>过程：web缓存器在收到报文后记录一个时间，在下次向服务器请求时带上这个时间并询问服务器这个页面是否在这个时间之后被修改，若修改，则发送新的报文给缓存器，若无，则回复 <code>304 not modified</code></strong></p>
</li>
<li><p>请求使用 GET method</p>
</li>
<li><p>header line： “If-Modified-Since：”</p>
<h2 id="2-3-电子邮件"><a href="#2-3-电子邮件" class="headerlink" title="2.3 电子邮件"></a>2.3 电子邮件</h2><h3 id="2-3-1SMTP"><a href="#2-3-1SMTP" class="headerlink" title="2.3.1SMTP"></a>2.3.1SMTP</h3></li>
<li><p><strong>过程：发送方调用邮件代理程序并提供接收方的邮件地址然后指示用户代理发送该报文，用户代理将报文发送给<code>发送方的邮件服务器</code>，在那里报文进入报文队列中，运行在发送方的邮件服务器的SMTP客户端发现了这个队列中的报文，（25号端口）创建一个到<code>接收方的邮件服务器</code>的TCP连接，在经过一些初始的SMTP握手后，SMTP客户通过该TCP连接发送报文，接收方的邮件服务器SMTP服务器端接收到了该报文，邮件服务器将报文放入接收方的邮箱之中。接收方调用用户代理阅读该报文。</strong></p>
</li>
<li><p>需要值得注意的是只有<code>发送方的邮件服务器</code>和<code>接收方的邮件服务器</code>，SMTP一般不使用中间服务器。如果接收方的邮件服务器没有开机，那么发送方的邮件服务器在后续会进行多次尝试。</p>
</li>
</ul>
<h3 id="2-3-2与HTTP对比"><a href="#2-3-2与HTTP对比" class="headerlink" title="2.3.2与HTTP对比"></a>2.3.2与HTTP对比</h3><table>
<thead>
<tr>
<th></th>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>都是一台主机向另一台发送信息</td>
<td>1、HTTP是一个拉协议；2、HTTP没有7比特ASCLL字符限制；3、HTTP把每个对象封装到一个报文中</td>
</tr>
<tr>
<td>SMTP</td>
<td>都是一台主机向另一台发送信息</td>
<td>1、SMTP是一个推协议；2、SMTP只能发送7比特的ASCLL字符；3、SMTP把所有对象封装到一个报文中</td>
</tr>
</tbody></table>
<h3 id="2-3-3邮件报文格式"><a href="#2-3-3邮件报文格式" class="headerlink" title="2.3.3邮件报文格式"></a>2.3.3邮件报文格式</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">From：alice<span class="hljs-symbol">@crepes</span>.fr<br><span class="hljs-keyword">To</span>:bob<span class="hljs-symbol">@hamburger</span>.edu<br>Subject:Searching <span class="hljs-keyword">for</span> the meaning of life<br></code></pre></td></tr></table></figure>
<h3 id="2-3-4邮件访问协议"><a href="#2-3-4邮件访问协议" class="headerlink" title="2.3.4邮件访问协议"></a>2.3.4邮件访问协议</h3><ul>
<li>之前我们默认是需要登录去访问邮件服务器的，而今天，邮件访问使用了一种**<code>客户-服务器体系结构</code>**，即用户使用桌面客户端来阅读电子邮件。</li>
<li>如果邮件服务器运行到用户设备上，那么保持持续在线是一件很困难的事。所以通常用户运行代理程序，而他访问总是开机的共享服务器上的邮件服务器。但是这又引发了一个问题：<strong>接收方是如何通过本地的代理程序来阅读程序的呢？（SMTP是一个推协议，所以无法使用SMTP来得到）</strong></li>
<li>上面这个问题的解决用到了一些特殊的邮件协议：**<code>POP3</code>和<code>IMAP</code>以及<code>HTTP</code>**<ul>
<li>POP3：<strong>过程分为三个阶段，第一阶段特许，服务器鉴别用户；第二阶段事务处理，用户代理取回报文，同时还可以选择对报文进行删除标记等；第三阶段更新阶段，即客户发出了quit命令之后，断开POP3连接，服务器删除被标记的报文</strong></li>
<li>IMAP：<strong>POP3无法为用户创建远程文件夹，也无法指派文件进入文件夹，所以IMAP应运而生，IMAP可以在邮件服务器接收邮件时与收件夹自动关联，后续在用户代理操作时可以指派文件夹，同时IMAP还可以选择只读取报文的首部，就可以避免一些下载不必要的大邮件。</strong></li>
</ul>
</li>
</ul>
<h2 id="2-4-DNS，域名解析服务"><a href="#2-4-DNS，域名解析服务" class="headerlink" title="2.4 DNS，域名解析服务"></a>2.4 DNS，域名解析服务</h2><p>工作机理：浏览器向用户DNS客户端发送主机名（gethostbyname），DNS客户端从缓存中查找，找不到向网络发送一个DNS查询报文，DNS请求和回答报文都是用UDP数据报经过53端口发送，DNS客户端将映射结果返回给调用的程序；</p>
<h3 id="2-4-1DNS提供的服务"><a href="#2-4-1DNS提供的服务" class="headerlink" title="2.4.1DNS提供的服务"></a>2.4.1DNS提供的服务</h3><ul>
<li><p>从主机名到ip地址转换目录服务。</p>
</li>
<li><p>DNS通常是其他应用层协议所使用的，它提供如下服务：</p>
<ul>
<li><p>从主机名到ip地址转换目录服务</p>
</li>
<li><p>主机别名</p>
</li>
<li><p>邮件服务器别名</p>
</li>
<li><p>负载分配</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-2DNS工作机理概述"><a href="#2-4-2DNS工作机理概述" class="headerlink" title="2.4.2DNS工作机理概述"></a>2.4.2DNS工作机理概述</h3><h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><ul>
<li><p>没有一台DNS服务器能够囊括全球域名，因此需要大量的DNS服务器，大致来说有三种：根DNS服务器，顶级域DNS服务器（tld），权威DNS服务器，还有一类： 本地DNS服务器，不过严格来说他不处于这个层次中</p>
</li>
<li><p><strong>过程：客户访问一个网址，首先向他的本地DNS服务器查询，本地DNS服务器将该报文转发到根DNS服务器，根DNS服务器再向本地DNS服务器返回负责这部分顶级域的tld-DNS服务器的ip地址列表，本地DNS服务器再向tld发送查询报文，tld再发送相关权威DNS服务器的ip地址，最后本地服务器再向权威服务器的ip发送报文，最后权威DNS服务器给出要访问的网址的ip地址，最后终于得到了ip地址</strong></p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4></li>
<li><p>DNS服务器会缓存IP/主机名的信息，在查询过程中的一级DNS服务器存储了这个ip就可以直接找到。</p>
</li>
</ul>
<h3 id="2-4-3DNS记录-DNS报文"><a href="#2-4-3DNS记录-DNS报文" class="headerlink" title="2.4.3DNS记录 DNS报文"></a>2.4.3DNS记录 DNS报文</h3><ul>
<li><p>资源记录：NAME|VALUE|TYPE|TTL</p>
<ul>
<li>NAME和VALUE的值主要取决于TYPE</li>
<li>TYPE分为A（主机名-ip）、NS（域如auswitz.top-知道如何获取该域主机ip的权威服务器）、CNAME（规范主机名-别名）、MX（邮件服务器的别名-规范主机名）</li>
<li>TTL：该记录的生存时间<h3 id="2-4-4DNS脆弱性"><a href="#2-4-4DNS脆弱性" class="headerlink" title="2.4.4DNS脆弱性"></a>2.4.4DNS脆弱性</h3></li>
</ul>
</li>
<li><p>针对DNS的DDos分布式拒绝服务带宽洪泛攻击，将大量分组发送到DNS服务器，以至于合法的分组得不到回答</p>
</li>
<li><p>但是，总而言之，DNS已经显示了惊人的鲁棒性，迄今为止，没有一个攻击有效的妨碍了DNS服务。</p>
</li>
</ul>
<h2 id="2-5-P2P"><a href="#2-5-P2P" class="headerlink" title="2.5 P2P"></a>2.5 P2P</h2><h3 id="2-5-1P2P结构的扩展性"><a href="#2-5-1P2P结构的扩展性" class="headerlink" title="2.5.1P2P结构的扩展性"></a>2.5.1P2P结构的扩展性</h3><p>在服务器-客户体系中，文件分发时，服务器必须向每一个对等方分发文件，<strong>但是在P2P文件分发中，每个对等方都能向其他任何对等方分发它已经接收到的文件的部分。</strong></p>
<h3 id="2-5-2BitTorrent"><a href="#2-5-2BitTorrent" class="headerlink" title="2.5.2BitTorrent"></a>2.5.2BitTorrent</h3><ul>
<li>BitTorrent时一种流行的P2P协议，参与一个特定文件分发的所有对等方被称为一个洪流（torrent），每个洪流有一个追踪器</li>
<li><strong>过程：当一个新的对等方加入洪流，它向追踪器注册自己，并周期性的告知自己仍在洪流中。当这个对等方A加入洪流时，追踪器随机的从对等方选择对等方的一个子集，将这个自己里的对等放的ip发给A，A就持有了这个子集的列表，试图与列表上的所有对等方建立TCP连接。称建立好连接的为邻近对等方，随着时间的流逝，这些邻近对等方会离开在任何给定的时间，每个对等方将获得来自文件的子集，并且不同对等方具有不同的子集，A周期性的向他的邻近对等方索要块列表，利用这个列表，A将针对它没有的块在邻居中请求最稀缺的块，这样最稀缺的块就能得到快速的分发。为了决定A响应哪个邻居的索要块的请求，A根据当前能够以最高速率向他提供数据的邻居，给出其优先权，并确定以最高速率流入的四个邻居，每过一段时间，A重新计算得到新的四个邻居(这四个对等方叫做疏通)，重要的是，A每过30s也要重新选择一个邻居发送块，将这个被选择的邻居称为B，A正在向B发送数据，因此A有机会称为B的疏通，这样B也有机会向A发送数据，也有希望继续成为A的疏通。他们将对方放入疏通成为对方的伴侣，直到该对等方之一发现了更好的伴侣。这种处理能够以趋于找到彼此协调的速率上载，随机选择邻居的方式也允许接触新的对等方，以便找到更好的伴侣。</strong><h2 id="2-6视频流和内容分发网络"><a href="#2-6视频流和内容分发网络" class="headerlink" title="2.6视频流和内容分发网络"></a>2.6视频流和内容分发网络</h2></li>
</ul>
<h3 id="2-6-1因特网视频"><a href="#2-6-1因特网视频" class="headerlink" title="2.6.1因特网视频"></a>2.6.1因特网视频</h3><h3 id="2-6-2HTTP和DASH"><a href="#2-6-2HTTP和DASH" class="headerlink" title="2.6.2HTTP和DASH"></a>2.6.2HTTP和DASH</h3><ul>
<li><p><strong>过程：视频只是存储在HTTP服务器上一个普通的文件，当用户要看视频时，客户服务器创建一个TCP连接，并发送该URL的HTTP-GET请求，服务器就以尽可能快的速率在报文中发送该视频文件，当缓存的字节数量超过设置的门槛，客户端就开始播放文件，同时继续缓存后面的视频帧。</strong></p>
</li>
<li><p>DASH：DASH允许允许不同质量的网络接入不同的视频版本的（4k、1080p等等）</p>
</li>
</ul>
<h3 id="2-6-3内容分发网"><a href="#2-6-3内容分发网" class="headerlink" title="2.6.3内容分发网"></a>2.6.3内容分发网</h3><ul>
<li><strong>过程：为了应对分发巨量数据的挑战，视频流公司都利用内容分发网CDN。用户请求一个视频，本地DNS服务器将请求发送到权威服务器，权威服务器观察到这是和视频相关的请求，就把CDN域中的主机名返回给本地DNS，这是本地DNS服务器的请求进入了CDN的DNS基础设施，此时CDN的DNS系统返回一个具有该视频的CDN服务器ip，本地DNS系统接收到后再返回给本地主机，主机和该CDN服务器创建一条TCP连接。最终用户能从该CDN服务器中获取想要的内容。</strong></li>
<li>集群选择策略：为了基于当前流量给客户更好的体验，CDN能够对其集群和客户的时延丢包进行周期性的测量。</li>
</ul>
<h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h1><h2 id="3-1-运输层服务"><a href="#3-1-运输层服务" class="headerlink" title="3.1 运输层服务"></a>3.1 运输层服务</h2><ul>
<li>运输层协议为运行在不同主机之间的应用程序提供了<strong>逻辑通信</strong>的功能</li>
<li>运输层从应用程序接受报文并转化成<strong>”报文段“</strong>，实现方式是将报文划分成较小的块，<strong>转换成运输层分组</strong>，并为每块加上一个运输层首部以生成运输层报文段，运输层协议是在端系统中而不是路由器中实现；</li>
<li><strong>报文分块</strong> – <strong>添加首部</strong> – <strong>生成报文段</strong> – 运输层将这些报文传递给网络层，网络层将其封装成数据报分组并向目的地发送；</li>
<li><strong>p123页的例子非常好，可以说明运输层协议只是工作在端系统。运输层协议将来自应用层的报文处理后挪到网络层边缘。</strong></li>
<li>路由器只会作用于网络层字段，不会检查封装在该数据报的运输层报文段和字段；运输层则处理接受到的报文段，使该报文的数据为接受应用程序使用；</li>
</ul>
<h3 id="3-1-1运输层和网络层的关系"><a href="#3-1-1运输层和网络层的关系" class="headerlink" title="3.1.1运输层和网络层的关系"></a>3.1.1运输层和网络层的关系</h3><ul>
<li>网络层提供了主机之间的逻辑通信</li>
<li>运输层提供了进程之间的逻辑通信</li>
<li>运输层协议只在端系统中工作；对报文在网络核心中如何移动不做任何规定；</li>
<li>不同的运输层协议为应用程序提供不同的服务模型</li>
<li>底层的网络层协议不可靠，分组交换机会发送分组丢失等，但是运输层协议仍然能够为应用程式提供可靠的数据传输；网络层协议有一个名字叫做<strong>IP（网际协议）</strong>，服务模型是尽力而为交付服务，因此被称为不可靠服务。</li>
</ul>
<h3 id="3-1-2概述"><a href="#3-1-2概述" class="headerlink" title="3.1.2概述"></a>3.1.2概述</h3><ul>
<li>运输层分组：报文段 segment TCP：报文段 UDP：数据报 网络层：数据报</li>
<li>IP的服务模型：<strong>尽力为交付服务</strong> best-effort delivery service，尽最大努力交付，但是不做任何确保，不确保报文段的交付、不确保报文段的按序交付、不确保报文段中的数据的完整性</li>
<li>IP：不可靠服务</li>
<li>TCP UDP的基本责任是：将两个端系统之间的IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务；</li>
<li>主机间的交付扩展到进程间的交付： <strong>运输层的多路复用</strong> 与 <strong>多路分解</strong> （transport-layer multiplexing, demultiplexing)</li>
<li><strong>进程和进程的数据交付</strong>和<strong>差错检查</strong>是两种最低限度的运输层服务</li>
</ul>
<h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><ul>
<li><p>多路分解：在接收端，运输层检查这些字段，标识出接收套接字，进而将报文定向到该套接字。</p>
</li>
<li><p>多路复用：从源主机不同套接字收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层。</p>
</li>
<li><p>报文段特殊字段的格式：<strong>源端口号|目的端口号|其他首部字段|应用数据</strong></p>
<h3 id="3-2-1无连接的多路分解和多路复用"><a href="#3-2-1无连接的多路分解和多路复用" class="headerlink" title="3.2.1无连接的多路分解和多路复用"></a>3.2.1无连接的多路分解和多路复用</h3></li>
<li><p>过程：<strong>主机A的运输层创建一个运输层报文段，其中包括应用程序数据、源端口号、目的端口号和其他。运输层就将这个报文传递给网络层。</strong></p>
</li>
<li><p>源端口号的目的是什么？提供一个完整的返回地址。</p>
</li>
<li><p>UDP的套接字是由一个<strong>二元组</strong>表示的，包含一个目的IP地址和一个目的端口号</p>
</li>
<li><p>源地址不同，目的地址相同，将被定向到同一个套接字。</p>
</li>
</ul>
<h3 id="3-2-2面向连接的多路分解和多路复用"><a href="#3-2-2面向连接的多路分解和多路复用" class="headerlink" title="3.2.2面向连接的多路分解和多路复用"></a>3.2.2面向连接的多路分解和多路复用</h3><ul>
<li>TCP的套接字是由一个<strong>四元组</strong>（目的IP、目的端口号、源IP、源端口号组成的）</li>
<li>不同源地址，相同目的地址，将被定向到两个不同的套接字。</li>
</ul>
<h3 id="3-2-3Web服务器与TCP"><a href="#3-2-3Web服务器与TCP" class="headerlink" title="3.2.3Web服务器与TCP"></a>3.2.3Web服务器与TCP</h3><ul>
<li>连接套接字与进程之间并非有着一一对应的关系，Web服务器具有多个新连接套接字的<strong>新线程</strong>，任意时间内会有不同标识的套接字连接到相同的进程中；线程管理的套接字可以接收或者发送HTTP请求和响应</li>
</ul>
<h2 id="3-3-无连接运输-UDP"><a href="#3-3-无连接运输-UDP" class="headerlink" title="3.3 无连接运输-UDP"></a>3.3 无连接运输-UDP</h2><ul>
<li><p>选择UDP的原因依据：</p>
<ul>
<li><p>时间和数据：不希望过分的延迟发送报文，且能容忍一定的数据丢失、</p>
</li>
<li><p>无需建立连接：UDP无连接时延</p>
</li>
<li><p>无连接状态：UDP无需维护连接状态，无需跟踪参数，无拥塞控制机制</p>
</li>
<li><p>分组首部开销小：源端口、目的端口、校验和、数据大小</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306141535242.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230306141535242"></p>
<h3 id="3-3-1UDP的报文段结构"><a href="#3-3-1UDP的报文段结构" class="headerlink" title="3.3.1UDP的报文段结构"></a>3.3.1UDP的报文段结构</h3><ul>
<li>首部包含四个字段每个字段由2个字节组成，一共8字节</li>
</ul>
<table>
<thead>
<tr>
<th>16bit</th>
<th>16bit</th>
</tr>
</thead>
<tbody><tr>
<td>源端口</td>
<td>目的端口</td>
</tr>
<tr>
<td>UDP报文首部和数据的总长度</td>
<td>校验和，对UDP报文段中的所有16比特字的和进行反码</td>
</tr>
<tr>
<td>报文数据</td>
<td>报文数据</td>
</tr>
</tbody></table>
<h3 id="3-3-2UDP校验和"><a href="#3-3-2UDP校验和" class="headerlink" title="3.3.2UDP校验和"></a>3.3.2UDP校验和</h3><ul>
<li>链路层路由协议及以太网协议也都提供了差错检测，传输层的差错检测存在的意义就是因为不能保证每一条链路都使用了差错检测的协议；这既是无法确保链路的可靠性；</li>
<li><strong>端到端原则</strong>： 必须基于端到端实现功能，因为相比在较高级别实现这些功能的代价，在较低级别上实现可以是冗余或者几乎无价值的；</li>
<li>UDP对检验出的受损报文段：1. 直接丢弃 2. 交给套接字并向应用程序发出<strong>警告</strong></li>
</ul>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><ul>
<li>可靠数据传输为上层实体提供的服务抽象： <strong>数据可以通过一条可靠的信道传输</strong></li>
<li>传输数据不会受损例如数据bit从0变为1或者从1变为0，且数据按照发送顺序交付</li>
<li>TCP的下层IP不可靠，TCP在不可靠的IP协议端到端网络层上实验可靠数据传输，且<strong>可靠数据传输协议</strong>下层可能是一条或者多条物理链路</li>
</ul>
<h3 id="3-4-1-构造可靠数据传输"><a href="#3-4-1-构造可靠数据传输" class="headerlink" title="3.4.1 构造可靠数据传输"></a>3.4.1 构造可靠数据传输</h3><h4 id="1-rdt1-0"><a href="#1-rdt1-0" class="headerlink" title="1. rdt1.0"></a>1. rdt1.0</h4><table>
<thead>
<tr>
<th>rdt1.0 - 发送端</th>
<th>{action}</th>
</tr>
</thead>
<tbody><tr>
<td>等待上次应用的调用</td>
<td>rdt_send(data)</td>
</tr>
<tr>
<td></td>
<td>packet = make_pkt(data); udt_send(packet)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>rdt1.0 - 接收端</th>
<th>{action}</th>
</tr>
</thead>
<tbody><tr>
<td>等待来自下层的调用</td>
<td>rdt_rev(packet)</td>
</tr>
<tr>
<td></td>
<td>extract(packet, data); deliver_data(data)</td>
</tr>
</tbody></table>
<ul>
<li>发送方和接收方都有各自的FSM，上图FSM各自只有一个状态</li>
<li>发送端：rdt的发送端只通过rdt_send(data)事件接收来自较高层的数据，然后生成一个包含数据的分组，并将分组发送到信道中；事件由上层应用的过程调用产生；</li>
</ul>
<blockquote>
<p>过程调用和系统调用</p>
</blockquote>
<ul>
<li>接收端：rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，然后从分组中取出数据extract，并将数据上传给高层deliver；rdt_rcv事件由较为底层的协议过程调用产生</li>
</ul>
<h4 id="2-rdt2-0"><a href="#2-rdt2-0" class="headerlink" title="2. rdt2.0"></a>2. rdt2.0</h4><ul>
<li><p>肯定确认 (positive acknowledgement) 否定确认 (negative acknowledgment)，控制报文使得接收方可以让发送发知道哪些内容被正确接收，哪些内容接收有误需要自动请求重传；</p>
</li>
<li><p><strong>自动重传协议</strong>  ARQ</p>
</li>
<li><p>自动重传协议</p>
<p>需要的支持</p>
<ul>
<li>差错检测，分组<strong>检验和</strong>字段</li>
<li>接收方反馈，“肯定确认” ACK，“否定确认” NAK</li>
<li>重传，接收方收到有差错的分组时，发送方收到反馈后将进行重传</li>
</ul>
</li>
</ul>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306143117832.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230306143117832"></p>
<ul>
<li>这样的等待协议为 <strong>停等</strong> 协议 stop-and-wait</li>
<li>接收方的FSM只有一个状态，当分组到达时，接收方检验分组是否受损，要么回答一个ACK要么回答一个NAK；</li>
<li>致命缺陷：没有考虑ACK、NAK受损的可能性。</li>
<li>解决ACK或者NAK分组受损导致发送方无法明确分组是否被正确接收的方法是：引入新字段，<strong>分组编号</strong>，就是发送数据的分组**序号 **</li>
</ul>
<h4 id="3-rdt-2-1-amp-amp-rdt2-2"><a href="#3-rdt-2-1-amp-amp-rdt2-2" class="headerlink" title="3 rdt 2.1&amp;&amp;rdt2.2"></a>3 rdt 2.1&amp;&amp;rdt2.2</h4><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306144235681.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230306144235681"></p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230306144301266.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230306144301266"></p>
<h4 id="3-rdt3-0-具有比特差错的丢包信道的可靠数据传输"><a href="#3-rdt3-0-具有比特差错的丢包信道的可靠数据传输" class="headerlink" title="3. rdt3.0 具有比特差错的丢包信道的可靠数据传输"></a>3. rdt3.0 具有比特差错的丢包信道的可靠数据传输</h4><blockquote>
<p>检测丢包和丢包后的action</p>
</blockquote>
<ul>
<li>当前已经包含的： 检验和、序号、ACK分组、重传机制</li>
<li>发送方等待超时，如果等待足够长的时间没有收到接收方的响应，便对该分组进行重传</li>
<li>等待时间： 发送方与接收方之间的一个往返时延（传输时延，传播时延，排队时延） + 接收方处理一个分组的时间， 实践中，发送方明智的选择一个确定的时间值作为等待时间</li>
<li>如果一个分组经历了比较长的时延，但是并没有丢包，发送方也会重传该分组，这样的情况下接收方就会 <strong>“冗余数据分组</strong>，分组序号可以解决冗余数据分组的问题</li>
<li>过度延时或者分组丢失都会导致重传</li>
<li>倒计数定时器 countdown timer， 用于给定时间过期后，中断发送方；</li>
</ul>
<table>
<thead>
<tr>
<th>发送方</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>等待来自上层的调用 0</td>
<td>rdt_send(data)</td>
</tr>
<tr>
<td></td>
<td>sndpkt = make_pkt(0, data, checksum); udt_send(sndpkt); start_timer;</td>
</tr>
<tr>
<td>等待ACK 0</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 1)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前0序号 则保持当前状态</td>
</tr>
<tr>
<td></td>
<td>timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为0的分组，并启动新的timer，发送后依然保持当前等待0响应的状态</td>
</tr>
<tr>
<td>⬇ 到下一状态</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 0)); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为0，则进入下一状态</td>
</tr>
<tr>
<td>等待来自上层的调用1</td>
<td>rdt_send(data)</td>
</tr>
<tr>
<td></td>
<td>sndpkt = make_pkt(1, data, checksum); udt_send(sndpkt); start_timer;</td>
</tr>
<tr>
<td>等待ACK 1</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 0)) # 等待响应分组，1. 下层过程调用rdt_rcv 2. 如果检验后数据受损 或 获得的确认包序号不是当前1序号 则保持当前状态, 继续等待正确响应分组</td>
</tr>
<tr>
<td></td>
<td>timeout; udt_send(sndpkt); start_timer; #如果出现超时(数据丢失或者网络延时)，则重新发送序号为1的分组，并启动新的timer，发送后依然保持当前等待0响应的状态</td>
</tr>
<tr>
<td>⬇ 到下一状态</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 1); stop_timer; #当在该状态下收到响应分组，调用rdt_rcv函数后，检验数据无损，且当前响应分组的序号与当前等待状态序号一致，此处为1，则进入下一状态</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>接收方</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>STATE</td>
<td>ACTION</td>
</tr>
<tr>
<td>等待来自下层的调用0（过程调用）</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq1(rcvpkt)) ; sndpkt = make_pkt(NAK, 0, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应</td>
</tr>
<tr>
<td>⬇ 到下一状态</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 0, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为0，则将数据提交给上层应用，并向发送方响应序号为0的ACK，当前状态转移到等待下层调用序号1</td>
</tr>
<tr>
<td>等待来自下层的调用1（过程调用）</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq0(rcvpkt)) ; sndpkt = make_pkt(NCK, 1, checksum); udt_send(sndpkt) #下层调用，检验数据是否受损, 检测分组序号，当数据受损或序号为1时，继续保持该状态等待下层调用0, 并发送0的NCK响应</td>
</tr>
<tr>
<td>返回初始状态</td>
<td>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt); extract(rcvpkt, data); deliver_data(data); sndpkt = make_pkt(ACK, 1, checksum); udt_send(sndpkt) # 接收分组，解出数据，校验数据无损且分组序号为1，则将数据提交给上层应用，并向发送方响应序号为1的ACK，返回初始状态</td>
</tr>
</tbody></table>
<h3 id="3-4-2-流水线可靠传输协议"><a href="#3-4-2-流水线可靠传输协议" class="headerlink" title="3.4.2 流水线可靠传输协议"></a>3.4.2 流水线可靠传输协议</h3><ul>
<li><p>rdt3.0的停等协议有着非常低的发送利用率 每个分组到达接收方后返回ACK的延时为一个RTT</p>
</li>
<li><p>解决方法：不使用停等协议等方式运行，允许发送方发送多个分组而无需等待确认；</p>
</li>
<li><p>流水线 pipelining</p>
</li>
</ul>
<p>  带来的影响</p>
<ul>
<li>必须增加序号范围，每个分组必须有一个唯一的序号</li>
<li>协议的发送方和接收方两端必须<strong>缓存多个分组</strong></li>
<li>序号范围和缓冲 取决于数据传输协议如何处理丢失、损坏、延时过大的分组；流水线的差错恢复的方法： <strong>回退N步 （Go-back-N GBN)**，</strong>选择重传 (Seletive Repeat, SR)**</li>
</ul>
<h3 id="3-4-3-回退N步"><a href="#3-4-3-回退N步" class="headerlink" title="3.4.3 回退N步"></a>3.4.3 回退N步</h3><blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>base nextseqnum</p>
<p>—–窗口长度—-</p>
<p>窗口到nextseqnum前是已发送但未确认分组，nextseqnum后是未发送分组</p>
</blockquote>
<ul>
<li>已经被发送但是还没有确认的分组的许可序号范围可以被看成一个在序号范围内的N的<strong>窗口</strong>；</li>
<li>N为<strong>窗口长度 window size</strong>， GBN协议也被称为<strong>滑动窗口协议 sliding window protocol</strong></li>
<li>运输层分组首部：分组序号，szie为k比特，则序号范围=[0, 2^k -1]，序号使用模2^k运算；</li>
<li>TCP的序号按照字节流中的字节计数</li>
<li>GBN响应的三种类型<ul>
<li>上层调用 rdt_send()，当前窗口未满时（判断是否已经有N个已经发送但是未被确认的分组），产生一个分组并发送，并更新变量；如果窗口已满，发送方需要将数据返回给上层，上层会稍等再试；</li>
<li>收到一个ACK，在GBN中，对序号为n的分组采用<strong>累计确认 cumulative acknowledgment</strong> 的方式，表明接收方已经正确接收n及n在内的所有的分组</li>
<li>超时事件，出现丢失和时延过长分组的情况下，发送方重传所有已经发送但是还未确认的分组，也就是重传当前窗口中的所有分组；</li>
</ul>
</li>
<li>GBN中，接收方，序号为n的分组被<strong>按序正确接收</strong>则接收方发送一个ACK，其他情况下接收方丢弃分组，并为最近按序接收的分组重新发送ACK；</li>
<li>如果序号为k的分组已经交付给上层，则证明k-1个分组都已经交付</li>
<li>因为数据必须按序交付，如果接收方等待分组n但是却收到了分组n+1，接收方会直接丢弃分组n+1，因为如果不丢弃会导致发送方重传，因此只需丢弃n+1，优点是接收缓存简单，接收方无需缓存失序分组；</li>
<li>发送方需要维护窗口的上下边界及nextseqnum在该窗口的位置，接收需要维护下一个按序接收的分组序号；且保存在expectedseqnum;</li>
</ul>
<blockquote>
<p>基于事件编程 event-based programming</p>
</blockquote>
<h3 id="3-4-4-选择重传"><a href="#3-4-4-选择重传" class="headerlink" title="3.4.4 选择重传"></a>3.4.4 选择重传</h3><ul>
<li>选择重传 SR 协议通过让发送方仅重传那些它怀疑在接收方出错（丢失、受损）的分组</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>base nextseqnum</p>
<p>—–窗口长度—-</p>
<p>nextseqnum前包含 已经确认的分组 和 已发送未确认分组</p>
<p>nextseqnum之后是 未发送分组</p>
</blockquote>
<ul>
<li>发送方和接收方的序号空间</li>
<li>发送发<ul>
<li>从上层接收数据，序号位于窗口内，将数据打包发送，如果不在窗口内，则将数据缓存或者将数据返回给上层；</li>
<li>超时，每个分组有自己的逻辑定时器，超时发生后只能发送一个分组，使用一个硬件定时器模拟多个逻辑定时器；</li>
<li>收到ACK，发送方收到ACK且判断在窗口内时，SR发送方将分组标记为“已接收”；当收到的序号等于send_base时，则base向前移动到<strong>“最小序号的未确认处”</strong>，如果序号为窗口内未发送分组，则发送这些分组</li>
</ul>
</li>
<li>接收方，将确认每个正确接收的分组，失序的分组将被缓存直到所有丢失分组都被收到为止；所有分组被收到后，将分组按序交付给上层；<ul>
<li>序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，收到的分组落在接收方的窗口内，选择ACK被会送给发送方；分组以前没有收到过，则缓存；分组序号为base序号，则触发该分组前的连续分组交付给上层；窗口向前移动并按照编号交付分组；</li>
<li>序号在[rcv_base, rcv_base + n -1]内的分组被正确接收，此时，必须产生一个AC</li>
</ul>
</li>
<li>接收方会重新确认（ACK）已经收到过的序号小于当前窗口base的分组；</li>
<li>SR中接收方和发送方的窗口不总是一致的；</li>
</ul>
<ul>
<li>对于SR协议，窗口的长度必须小于或者等于序号空间大小的一半；</li>
<li>Page153，对于发送方窗口序号为0，1，2，3，0，1，2 窗口长度为3，接收方无法判断序号为0的分组是重传还是第五个分组的初次传输；此处序号空间是4，但是窗口size为3，导致协议无法工作；</li>
</ul>
<h5 id="可靠数据传输机制总结"><a href="#可靠数据传输机制总结" class="headerlink" title="可靠数据传输机制总结"></a>可靠数据传输机制总结</h5><table>
<thead>
<tr>
<th>机制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>检验和 checksum</td>
<td>检验分组数据bit是否受损</td>
</tr>
<tr>
<td>定时器timer</td>
<td>用于分组丢失的情况下的超时重传，分组丢失或者ACK回复在链路中丢失，或者因为链路时延导致超时；重传可能会导致接收方的分组冗余</td>
</tr>
<tr>
<td>序号 sequence number</td>
<td>对从发送方到接收方的数据按序编号，发送方可以按序交付数据给接收方，接收方通过序号检测数据是否受损或者丢失并向发送方回复；接收方还可以通过序号检测是否收到了冗余副本；</td>
</tr>
<tr>
<td>确认 ACK</td>
<td>接收方用于确认一个分组或者一组分组是否正确接收，携带被确认的分组的序号或者多个序号，确认可以逐个也可以是积累的；</td>
</tr>
<tr>
<td>否定确认 NAK</td>
<td>接收方用于回复发送方某一个序号的分组未正确接收，例如数据顺坏，携带被否定确认的分组的序号；</td>
</tr>
<tr>
<td>窗口、流水线 sliding window</td>
<td>发送方通过一次发送多个分组，不断更新窗口位置，接收方每次收到base序号的分组后，则将缓存中的分组交付给上层；窗口长度根据接收方 接收 和 缓存 报文的能力、网络拥塞程度来配置；</td>
</tr>
</tbody></table>
<ul>
<li>通过假定一个分组在网络中“存活”时间不会超过一个最大的固定时间（最大分组寿命3分钟），来确保一个序号的分组都已经不再网络中，则可以重复使用该序号；对序号的重复使用会导致冗余分组和当前分组的混乱，所有重复使用序号的前提是必须保证网络中不再包含该序号的分组；</li>
</ul>
<h2 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h2><h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1 TCP连接"></a>3.5.1 TCP连接</h3><ul>
<li>发送预备报文段，进行握手，以建立确保数据传输的参数，进而建立<strong>“连接”</strong>；</li>
<li>TCP/IP Transmission Control Protocol/Internet Protocol，建立之初为单一的实体，后来将其分开为TCP和IP协议，存在于网络的不同层次</li>
<li>连接状态完全保留在两个端系统中，中间网络不会维持TCP连接，中间网络对TCP连接完全“视而不见”</li>
<li>全双工服务（full-duplex service）；进程A和进程B可以同时发送数据；</li>
<li>点对点（point-to-point），单个发送方和单个接收方； </li>
</ul>
<h5 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h5><ul>
<li>客服进程、服务器进程</li>
</ul>
<blockquote>
<p>clientSocket.connect((serverName, serverport))</p>
</blockquote>
<ul>
<li><p>两个进程之间发送了3个报文段，前两个不承载“有效载荷”，建立的过程被称为<strong>三次握手</strong></p>
</li>
<li><p><strong>过程：1、客户端发送连接请求 SYN=1 SEQ=随机x    2、服务器为TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。SYN=1 ACK=1 SEQ=随机y ack=x+1    3、客户端为该客户端连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。</strong></p>
<h5 id="连接的释放"><a href="#连接的释放" class="headerlink" title="连接的释放"></a>连接的释放</h5></li>
<li><p><strong>过程：1、客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接 FIN=1 SEQ=u    2、服务器端返回确认报文段，连接释放 ACK=1 SEQ=v ack=u+1半关闭状态    3、服务器端发完数据，发出连接释放报文段，主动关闭TCP连接FIN=1 ACK=1 SEQ=w ack=u+1    4、客户端回复确认报文端，等待计时器设置的2msl（最长报文段寿命）连接彻底关闭</strong></p>
</li>
</ul>
<h3 id="3-5-2-报文段-结构"><a href="#3-5-2-报文段-结构" class="headerlink" title="3.5.2 报文段 结构"></a>3.5.2 报文段 结构</h3><ul>
<li>32bit</li>
</ul>
<table>
<thead>
<tr>
<th align="center">32bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">源端口号 | 目的端口号</td>
</tr>
<tr>
<td align="center">序号</td>
</tr>
<tr>
<td align="center">确认号</td>
</tr>
<tr>
<td align="center">首部长度|保留未用|URG|ACK|PSH|RST|SYN|FIN | 接收窗口</td>
</tr>
<tr>
<td align="center">检验和 | 紧急数据指针</td>
</tr>
<tr>
<td align="center">选项</td>
</tr>
<tr>
<td align="center">数据</td>
</tr>
</tbody></table>
<ul>
<li><strong>MSS限制了报文段数据字段的最大长度</strong>，对于较大的文件，TCP会将文件划分成若干块进行处理</li>
<li>和UDP相同，首部包括了源和目的端口、检验和字段（checksum）</li>
<li>32bit的序号字段，32bit的确认号字段</li>
<li>16bit的接收窗口字段，用于流量控制，用于指定接收方愿意接收的字节数量</li>
<li>4bit的首部长度字段，典型长度为20byte</li>
<li>选项字段，可变长度用于协商MSS</li>
<li>6bit的标志字段 flag field<ul>
<li>ACK 用于确认报文段是否被成功接收，1 bit</li>
<li>RST、SYN、FIN用于连接的建立和拆除，1bit</li>
<li>PSH表示，是否立即将数据交付给上层，1bit，运输层传递给应用层的优先级++</li>
<li>URG表示，报文段中是否 ”存在“ 被发送端的上层实体置为”紧急“的数据</li>
<li>紧急数据指针字段用于指出紧急数据，存在时TCP会通知上层服务；16bit</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-往返时间与超时"><a href="#3-5-3-往返时间与超时" class="headerlink" title="3.5.3 往返时间与超时"></a>3.5.3 往返时间与超时</h3><ul>
<li>TCP使用超时重传机制</li>
<li><strong>超时间隔是动态确定的</strong></li>
<li>TCP使用 SampleRTT来<strong>预估 一次的RTT时间</strong>，TCP会维持一个平均值<strong>EstimateRTT</strong>，当获取到新的SampleRTT，计算加权平均值的方式如下：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">EstimatedRTT</span> = （<span class="hljs-number">1</span>- α）· EstimatedRTT + α · SampleRTT<br><span class="hljs-attr">DevRTT</span> = (<span class="hljs-number">1</span>-β) · DevRTT + β · |SampleRTT - EstimatedRTT|<br></code></pre></td></tr></table></figure>
<blockquote>
<p>α参考值为0.125，β推荐值为0.25</p>
<p>指数加权移动平均</p>
<p>定义了DevRTT为SampleRTT到EstimatedRTT的偏离程度</p>
</blockquote>
<ul>
<li>考虑到SampleRTT的波动，超时重传的时间间隔</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TimeoutInterval</span> = EstimatedRTT + <span class="hljs-number">4</span> · DevRTT<br></code></pre></td></tr></table></figure>
<ul>
<li>初始推荐为1秒</li>
</ul>
<h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4 可靠数据传输"></a>3.5.4 可靠数据传输</h3><ul>
<li>回顾：IP协议的不可靠，数据报可能会溢出路由器输出缓存，数据报达到目的地址乱序，数据报在传输过程中比特可能损坏；</li>
<li>TCP是在IP的不可靠服务上创建的可靠数据传输服务（reliable data transfer service）</li>
<li>确保：进程从接收缓存中读取的数据流是无损坏、无间隔、非冗余、按序</li>
</ul>
<h4 id="单一重传定时器简化描述"><a href="#单一重传定时器简化描述" class="headerlink" title="单一重传定时器简化描述"></a>单一重传定时器简化描述</h4><ul>
<li>事件一，TCP从应用层接收数据，并将数据进行封装，报文段被发送给IP时，TCP启动<strong>定时器</strong>，这里定时器的timeout时间是前面提到的TimeoutInterval，由EstimatedRTT和DevRTT计算得出</li>
<li>事件二，发送方处理来自接收方的ACK（这里的ACK被包含数据的报文段捎带），TCP将ACK确认号与窗口变量SendBase进行比较，因为累计确认，ACK的值确认了该值前的所有序号的数据都已经正确接收，发送方更新SendBase后，TCP需要重启定时器；</li>
<li>事件三，超时重传。</li>
</ul>
<h4 id="一些有趣的情况-p161"><a href="#一些有趣的情况-p161" class="headerlink" title="一些有趣的情况 p161"></a>一些有趣的情况 p161</h4><ul>
<li>第一种，确认报文丢失，发送端重传报文，接收端接收重传的报文，<strong>并替换原来的部分报文。</strong></li>
<li>第二种，同时有两个连续的报文被接收，但是两个确认报文都没有到达发送端，超时事件发生后，主机a重传第一个，若新的超时发生之前，发送端收到了第二个报文的ACK，那么发送端不用再重发第二个报文。</li>
<li>第三种，前一个ACK丢失，但后面的ACK被收到，由于累计机制，所以不会重传。</li>
</ul>
<h4 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h4><ul>
<li>超时事件发生，TCP重传具有最小序号的还未被确认的报文段；每次重传将下一次的超时时间间隔设置为先前值的2倍，而不是使用计算值，定时器在收到上层数据或者收到ACK报文段时将恢复计算时间为超时时间间隔；</li>
<li>这里的超时时间间隔的指数型增长，提供了一种简单形式的拥塞控制；</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><blockquote>
<p>冗余ACK就是再次确认某个报文段的ACK</p>
</blockquote>
<ul>
<li><p>超时周期可能太长</p>
</li>
<li><p>接收方收到3个冗余ACK（快速重传的条件是3个冗余 ？为什么），TCP执行<strong>快速重传</strong>，即在该报文段定时器超时前重传丢失报文段；</p>
</li>
</ul>
<h4 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h4><p>有选择的确认失序报文段，而不是累积到最后一个正确接收的有序报文段，与选择重传相结合；</p>
<h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5 流量控制"></a>3.5.5 流量控制</h3><ul>
<li>流量控制区别于拥塞控制：<strong>流量控制是为了消除发送方使接收方缓存溢出的可能性，拥塞控制是为了处理因IP网络的拥塞造成的遏制。</strong></li>
<li>TCP缓存溢出：TCP的两则都有接收缓存，TCP接收到正确的、按序的字节后，将数据放入缓存，应用程序从缓存中读取数据，如果应用当前其他事务繁忙，则有可能发送缓存溢出的情况；</li>
<li>流量控制服务（Flow-control service），匹配发送方的发送速率和接收方应用程序的读取速率；</li>
<li>流量控制<ul>
<li>RcvBuffer：配置的接收缓存的大小</li>
<li>LastByteRead：从缓存中读取的数据的最后一个字节的编号</li>
<li>LastByteRcvd：达到的按序报文段放入缓存的数据流的最后一个字节的编号</li>
<li>LastByteRcvd - LastByteRead &lt;= RcvBuffer 必须成立才可不发生溢出</li>
<li><strong>当前的接收窗口：rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</strong></li>
<li>rwnd空间为动态变化的空间，rwnd值会被接收主机放入发给发送方的报文段的<strong>”接收窗口“</strong>字段，开始时rwnd = RcvBuffer</li>
<li>发送方跟踪的变量：LastByteSent, LastByteAcked</li>
<li>发送方在整个连接的生命周期内必须保证： LastByteSent - LastByteAcked &lt;= rwnd</li>
<li>发送方要保证，当前所有未被确认的数据长度一定小于等于接收方返回的窗口长度</li>
<li>特殊情况：接收方窗口为0时，发送发将继续发送只有一个字节数据的报文段，接收方确认，当缓存清空后，确认报文将包含一个非0的窗口值rwnd；这里再清空前还是会发生重传；</li>
<li>注意：UDP不存在流量控制，所有对于UDP会出现缓存溢出</li>
</ul>
</li>
</ul>
<h3 id="3-5-6-TCP的连接管理"><a href="#3-5-6-TCP的连接管理" class="headerlink" title="3.5.6 TCP的连接管理"></a>3.5.6 TCP的连接管理</h3><ul>
<li>TCP连接的建立与拆除</li>
<li>连接建立的过程会显著增加用户感受到的时延</li>
<li>网络攻击利用TCP连接管理的弱点、</li>
</ul>
<h4 id="连接建立的步骤"><a href="#连接建立的步骤" class="headerlink" title="连接建立的步骤"></a>连接建立的步骤</h4><blockquote>
<p>isn = identity sequence number</p>
</blockquote>
<ol>
<li>第一步，<strong>客户的TCP服务向服务端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是报文段的首部的标志位“SYN”的比特被置为1</strong>；客户随机选择一个起始序号（client_isn），并将该编号放在TCP SYN报文段的序号字段中；<strong>表示发起建立新的连接</strong></li>
<li>第二步，包含TCP SYN报文段的IP数据报到达服务端，服务器从数据报中提取TCP SYN报文段，为TCP连接分配缓存和变量（这里分配的缓存和变量容易受到洪泛攻击），<strong>并发送允许连接的报文段</strong>，允许连接的报文段：不包含任何应用层数据，SYN标志位被置为1，确认号为client_isn+1，序号为随机选择的服务器初始序号 server_isn；<strong>表示收到了发起连接的SYN的client_isn，同意建立连接，称作SYNACK报文段(SYNACK segment)</strong></li>
<li>第三步，客户收到SYNACK报文段后，客户给该连接分配缓存和变量，**客户向服务端发送一个对服务端SYNACK的确认，确认序号为server_isn+1，且SYN被置为0，这个数据报中可以携带客户应用层数据；</li>
</ol>
<ul>
<li>这个步骤被称为“3次握手”，从第三个步骤开始次周的报文段传输的过程中SYN标志位都为0，建立的过程中交换了3个分组；</li>
</ul>
<h4 id="连接拆除的步骤"><a href="#连接拆除的步骤" class="headerlink" title="连接拆除的步骤"></a>连接拆除的步骤</h4><blockquote>
<p>两个进程都可以终止当前的连接，连接接收后，TCP服务分配的缓存和变量都会被释放和回收；</p>
</blockquote>
<ol>
<li>客户应用程序发起关闭连接的命令，客户TCP向服务器发送报文段：首部标志位FIN被置为1；</li>
<li>服务器收到FIN 为1的报文段后，向发送发会送一个确认报文段；</li>
<li>服务器发送自己的终止报文段，其FIN比特被置为1；</li>
<li>客户向服务端发送的终止报文段，发送一个确认，此时两台主机上用于该连接的所有资源都被释放；</li>
</ol>
<h3 id="3-6-TCP拥塞控制原理"><a href="#3-6-TCP拥塞控制原理" class="headerlink" title="3.6 TCP拥塞控制原理"></a>3.6 TCP拥塞控制原理</h3><ul>
<li><strong>异步传递方式 ATM</strong></li>
<li><strong>可用比特率 ABR</strong></li>
</ul>
<h4 id="3-6-1-拥塞代价"><a href="#3-6-1-拥塞代价" class="headerlink" title="3.6.1 拥塞代价"></a>3.6.1 拥塞代价</h4><ul>
<li>代价1：当分组到达的速率接近链路容量时，分组经历了巨大的排队时延；</li>
<li>代价2：发送方必须执行重传以补偿因为缓存益处导致的分组丢失</li>
<li>代价3：发送方再遇到网络时延较大的情况下，会重传分组，导致路由器会利用链路带宽来转发一个不需要的分组副本；</li>
<li>代价4：一个分组沿着一条路径被丢弃时，每个上游的路由器对该分组的转发都是在浪费传输容量；</li>
</ul>
<h4 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2 拥塞控制方法"></a>3.6.2 拥塞控制方法</h4><ul>
<li><strong>端到端拥塞控制</strong>：TCP通过端到端的方法解决拥塞问题，<strong>IP层不会向端系统提供有关网络拥塞的反馈</strong>；TCP接收方通过三次冗余确认告知接收方报文段的丢失，报文段的丢失就是一种网络拥塞的迹象，TCP会<strong>相应的减小窗口长度</strong>，往返的时延值作为网络拥塞程度的指示；</li>
<li><strong>网络辅助的拥塞控制</strong>：网络层的路由器会向发送方提供关于链路中的拥塞情况；反馈方式为，阻塞分组（choke packet），路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生；收到标记的分组后，接收方就会向发送方通知网络的拥塞；<strong>ATM拥塞控制（路由器显式的通知发送方链路支持的最大主机发送速率）</strong></li>
</ul>
<h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h3><ul>
<li><p><strong>TCP使用端到端的拥塞控制机制，IP层不向端系统显示的提供任何网络拥塞程度的反馈；</strong></p>
</li>
<li><p>采用的方法：<strong>让每个发送方根据所感知的到的网络的拥塞程度来限制向连接发送流量的速率，动态调整流量发送速率，无拥塞时增加速率，有拥塞时降低速率；</strong></p>
</li>
<li><p>TCP拥塞控制算法（TCP congestion control algorithm）</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速恢复</li>
</ul>
</li>
</ul>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><ul>
<li><p>slow-start，发送方的起始cwnd值为一个MSS，起始发送速率为MSS/RTT，每当传输的报文段首次被确认接收ACK，cwnd就增加一个MSS，在这个过程中每一个RTT，cwnd的值就会翻番，起始阶段很慢，<strong>但是在整个慢启动阶段以指数增加；</strong></p>
</li>
<li><p>慢启动对超时和丢包事件的处理，即发送拥塞时的处理，有两种方式：</p>
<ul>
<li>1是将cwnd设置为1重新开始慢启动过程，将ssthresh（慢启动阀门）设置为cwnd/2，当出现拥塞将ssthresh设置为拥塞窗口的一半；</li>
<li>2是当cwnd的值等于ssthresh时，结束慢启动并且将TCP转移到<strong>”拥塞避免模式“</strong>；</li>
</ul>
</li>
<li><p>当检测到3个冗余ACK，这时TCP执行一种快速重传并进入<strong>快速恢复状态</strong>；</p>
</li>
</ul>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><ul>
<li>进入拥塞避免的TCP，cwnd的值大约是遇到拥塞时的一半，这时每个RTT的确认ACK只将cwnd的值<strong>增加1个MSS</strong>；</li>
<li>出现超时：cwnd的值被设置为1个MSS，ssthresh被设置为cwnd/2，并进入慢启动状态；</li>
<li>出现冗余ACK事件：TCP将cwnd减半，加上三个ACK的3个MSS，进入快速恢复状态</li>
</ul>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><ul>
<li>进入快速恢复后，对每个收到的冗余报文段的ACK，cwnd的值增加一个MSS，当丢失报文的一个ACK到达时，TCP再降低cwnd后进入拥塞避免状态；</li>
<li>出现超时，执行与拥塞避免相同的操作，进入慢启动状态；</li>
<li>出现丢包，cwnd的值设置为1个MSS，将ssthresh的值设置为cwnd的一半；</li>
</ul>
<h5 id="全局回顾"><a href="#全局回顾" class="headerlink" title="全局回顾"></a>全局回顾</h5><blockquote>
<p>当TCP通过3个冗余ACK感知到了丢包，TCP进行的拥塞控制是：每个RTT内cwnd线性增加1MSS，出现3个冗余ACK事件时cwnd减半；</p>
</blockquote>
<ul>
<li>TCP拥塞控制：<strong>加性增</strong>，<strong>乘性减</strong></li>
</ul>
<h5 id="吞吐量的宏观描述"><a href="#吞吐量的宏观描述" class="headerlink" title="吞吐量的宏观描述"></a>吞吐量的宏观描述</h5><ul>
<li>一天连接的平均吞吐量<code>0.75 x w /RTT</code> ，这里的w表示当前拥塞窗口的长度；</li>
</ul>
<h4 id="3-7-1-公平性"><a href="#3-7-1-公平性" class="headerlink" title="3.7.1 公平性"></a>3.7.1 公平性</h4><ul>
<li>与UDP：UDP没有内置的拥塞控制，UDP上的应用需要好以恒定的速率将数据注入网络中，UDP连接在TCP的观点看来时不公平的，因为它不与其他的连接合作，也不会适时的调整传输速率，TCP的拥塞控制在面临拥塞增加时，会降低其传输速率，原则上UDP并不会这样做；<strong>UDP源可能会压制TCP流量；</strong></li>
<li>与并行TCP：TCP应用建立的并行连接会导致网络中应用程序带宽分配的不公平，比如一个WEB来建立多个TCP去传输多个对象；</li>
</ul>
<hr>
<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><ul>
<li><p>两个部分：</p>
<ul>
<li>数据平面：从其输入链路向其输出链路转发数据报</li>
<li>控制平面：协调这些本地路由器的转发动作</li>
</ul>
</li>
<li><p>交付方式</p>
<ul>
<li>数据报模式：因特网所采用的</li>
<li>虚电路模式</li>
</ul>
</li>
<li><p>网络层功能</p>
<ul>
<li>转发 forwarding</li>
<li>路由选择 routing</li>
<li>网际协议IP IPv4, IPv6</li>
<li>网络地址转换NAT</li>
<li>数据报分段</li>
<li>因特网控制报文协议ICMP</li>
<li>路由选择算法：链路状态和距离矢量算法，等级制路由选择方法；RIP，OSPF，IS-IS，BGP</li>
</ul>
</li>
</ul>
<h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><ul>
<li>路由器的主要作用是将数据报（data grama）从入链路转发到出链路，路由器具有截断的协议栈，即没有网络层以上的部分；路由器除了控制目的外，不运行网络层以上的协议；、</li>
</ul>
<h3 id="4-1-1-转发和路由选择"><a href="#4-1-1-转发和路由选择" class="headerlink" title="4.1.1 转发和路由选择"></a>4.1.1 转发和路由选择</h3><ul>
<li><p><strong>转发：</strong>将分组从输入链路移动到适当的输出链路的过程</p>
</li>
<li><p><strong>路由选择：</strong>网络层需要决定分组从发送方到接收方所要采用的路径或者路由，计算这些路径的算法为<strong>路由选择算法</strong> routing algorithm</p>
</li>
<li><p>每台路由器有一张</p>
<p>转发表（forwarding table）</p>
<ul>
<li>转发表存储：分组首部的值和路由表的输出链路接口</li>
<li>路由器通过检查到达的分组首部的字段，用该字段值再转发表中查询，从而找出输出链路的接口</li>
<li>路由选择算法，决定了插入路由器的转发表中的值，路由选择算法可能是集中式的也可能是分布式的；</li>
<li>路由器接收路由选择协议报文，将报文信息用以配置路由转发表；</li>
</ul>
</li>
<li><p>控制平面传统方法：路由选择算法运行在每台路由器中，并在每台路由器中都含有转发和路由选择这两种功能</p>
</li>
<li><p>控制平面SDN方法：路由选择设备仅支持转发，而远程控制器计算并分发转发表</p>
</li>
</ul>
<h3 id="4-1-2-网络服务模型"><a href="#4-1-2-网络服务模型" class="headerlink" title="4.1.2 网络服务模型"></a>4.1.2 网络服务模型</h3><ul>
<li>网络服务模型 network service model 定义了分组再发送与接收端系统之间端到端的端运输特性</li>
<li>网络层提供的服务/特性<ul>
<li>确保交付：确保分组最终到达目的地</li>
<li>具有时延上界的确保交付：确保分组交付，且再特定主机到主机时延上界内交付</li>
<li>有序分组交付：分组按照发送顺序达到目的地</li>
<li>确保最小带宽：主机以低于特定比特率的速率传输比特，则不会发送分组丢失，且分组再预定的时延内到达；</li>
<li>确保最大时延抖动：确保发送方两个相继分组间的时间量 = 目的地接收两个分组之间的时间量</li>
<li>安全性服务，使用源和目的主机知道的会话密钥，再源主机的网络层加密向目的主机发送的所有数据报负载；</li>
</ul>
</li>
<li>因特网<strong>尽力而为服务</strong>，分组间的定时不能被保证，分组接受顺序也不能保证，发送分组最终是否能交付也不能保证；但是实践证明，足够好</li>
</ul>
<h3 id="4-1-3-虚电路和数据报网络"><a href="#4-1-3-虚电路和数据报网络" class="headerlink" title="4.1.3 虚电路和数据报网络"></a>4.1.3 虚电路和数据报网络</h3><ul>
<li>网络层的面向连接服务和无连接服务<ul>
<li>网络层的面向连接服务和无连接服务向运输层提供主机到主机的服务，运输层则是向应用层提供进程到进程之间的服务；</li>
<li>只在网络层提供连接服务的网络：<strong>虚电路网络 Virtual-Circuit VC</strong></li>
<li>只在网络层提供无连接服务的网络：<strong>数据报网络 datagram network</strong></li>
<li>运输层的连接服务只在网络边缘的端系统中实现，网络层的连接服务再端系统中和网络核心的路由器中实现；</li>
<li>计算机网路的两种基本类型：<strong>虚电路网络， 数据报网络</strong></li>
</ul>
</li>
</ul>
<h5 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h5><ul>
<li>ATM、帧中继的体系结构都是虚电路网络，在网络层使用连接，成为虚电路；</li>
<li>虚电路的组成：<ul>
<li>源和目的之间的路径，链路和路由器</li>
<li>VC号，沿着该路径的每段链路的一个号码；</li>
<li>沿着路径的每台路由器中的转发表表项；<ul>
<li>每台路路由器会为分组替换一个新的VC号，分组在每条链路上有不同的VC号，且再分组的首部携带；</li>
<li>路由器的转发表会管理入VC号字段和对应的出VC号字段；</li>
<li>创建虚电路对路由器新增转发项，终止一条虚电路，删除相应的转发表项；</li>
<li>路由器需要对进行中的连接 维持<strong>连接状态信息</strong>，分组跨越一个路由器就创建新连接，增加路由器的表项，每释放一个连接从表中删除表项；</li>
</ul>
</li>
</ul>
</li>
<li>虚电路的3个阶段<ul>
<li>虚电路建立，运输层向网络层指定接收方地址，网络层决定一条分组通过的路径，网络层沿着路径向链路中的每一个路由器节点决定VC，在转发表中增加表项；</li>
<li>数据传输，分组沿着创建号的虚电路流动；</li>
<li>虚电路拆除，发送方或者接收方通知网络层希望终止该电路时，网络层会通知另一侧的端系统结束呼叫并更新路径上的每台路由器的转发表；</li>
</ul>
</li>
<li>沿着两个端系统之间的路径上的路由器都要参与虚电路的建立，且<strong>每台路由器都完全知道通过它的所有虚电路</strong>；</li>
</ul>
<h5 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h5><ul>
<li>端系统为想要发送的分组加上目的端系统的地址，然后将分组推进网络中；路由器不维护任何虚电路；</li>
<li>分组在链路中经过每一台路由器，<strong>路由器都是用分组目的地址来对分组进行转发</strong>；</li>
<li>每台路由器维护一个<strong>链路接口转发表</strong>用来给目的地址做映射，对于到达分组，路由器会使用其首部的目的地址在链路转发表中查找适当的输出链路接口；然后路由器将分组向该接口转发；</li>
<li>IPv4地址长度 32 位bit，4段（4 group）</li>
<li>IPv6地址长度128位bit，8段（16进制，8group）</li>
<li>转发表：路由器用分组的目的地址的<strong>前缀（prefix）</strong>与该表中的表项进行匹配；当初先多匹配时，例如一个分组的目的地址与转发表中的21位表项匹配且又与24位表项匹配，<strong>则路由器使用最长前缀匹配规则</strong>，将该分组转发到24位表项相匹配的输出链路接口上，路由器总是在<strong>链路接口转发表中</strong>匹配最长的prefix，最长匹配项；最长匹配与编址规则有关；</li>
<li>路由器维护的转发表，维持了转发转台信息，转发表由<strong>路由选择算法进行更新和修改</strong>，路由器建立新连接和拆除一条连接都会更新转发表；</li>
</ul>
<hr>
<p>这一部分是数据平面相关的内容</p>
<p>需要更细致的了解<strong>分组交换机</strong>：</p>
<ul>
<li>链路层交换机：基于链路层帧中的字段值做出决定</li>
<li>路由器：基于网络层帧的字段做出决定</li>
</ul>
<h2 id="4-2-路由器的工作原理"><a href="#4-2-路由器的工作原理" class="headerlink" title="4.2 路由器的工作原理"></a>4.2 路由器的工作原理</h2><ul>
<li><p><strong>转发功能</strong>：将分组从路由器的入链路传送到适当的出链路</p>
</li>
<li><p>路由器的体系结构</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307163533160.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230307163533160"></p>
</li>
<li><p>输入端口：</p>
<ul>
<li><p>物理层功能：将一条输入链路与路由器相连接</p>
</li>
<li><p>数据链路层功能：与位于入链路远端的数据链路层交互</p>
</li>
<li><p>通过查询转发表决定输出端口，到达分组通过路由器的交换结构转发到输出端口；</p>
</li>
<li><p>将“控制分组”从输入端口转发到路由器的“选择处理器”，（携带路由选择控制协议的分组）</p>
<blockquote>
<p><strong>端口</strong>，这个词语在网络硬件中表示，路由器物理的输入和输出接口；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>交换结构：</p>
<ul>
<li>与输入端口和输出端口相连，交换结构完全包换在路由器中，网络路由器中的网络；</li>
</ul>
</li>
<li><p>输出端口：</p>
<ul>
<li>存储从交换结构接收的分组</li>
<li>执行相应的物理层和链路层功能，在输出链路上传输分组</li>
<li>双向链路，输出端口和输入端口在同一线路卡上成对出现；</li>
</ul>
</li>
<li><p>路由选择处理器：</p>
<ul>
<li>执行路由选择协议</li>
<li>维护路由表及连接的链路状态信息</li>
<li>计算转发表</li>
<li>执行网络管理功能</li>
</ul>
</li>
<li><p><strong>路由转发平面 router forwarding plane</strong> ：路由转发是路由器用输入输出端口、交换结构共同实现的转发功能，总是用“硬件”实现；</p>
<ul>
<li>路由器对n个端口数据的处理，数据处理流水线需要n倍的处理速率，通过厂商定制的硬件来实现这样的功能；</li>
</ul>
</li>
<li><p><strong>路由器控制平面 router control plane</strong> ：通过软件实现，路由器的控制功能，包括执行路由选择协议，对上线和下线的连接链路进行响应，及路由的管理功能；</p>
</li>
<li><p>路由器和交换机的设计面对一系列的拥堵问题；</p>
</li>
</ul>
<h3 id="4-2-1-输入端口"><a href="#4-2-1-输入端口" class="headerlink" title="4.2.1 输入端口"></a>4.2.1 输入端口</h3><ul>
<li>输入端口的<strong>线路端接功能</strong> 与 <strong>链路层处理</strong> 实现了用于各个输入链路的物理层和链路层，执行输出链路处理，包括链路协议，和分组的拆封；</li>
<li>输入端口中：<strong>路由器使用转发表来查找输出端口</strong>，最长前缀匹配，使得到达的分组能够经过交换结构转发到该输出端口；</li>
<li>转发表由路由器的选择处理器计算和更新，转发表的一份影子副本通常会被存放在每个输入端口；</li>
<li>转发表从路由选择处理器经过独立总线，复制到线路卡；</li>
<li>影子副本的作用：在每个端口本地作出转发决策，无需调用中央路由选择处理器，避免了集中式处理的瓶颈；</li>
<li>因为交换结构可能会被其他的分组使用，当前已经匹配了转发表项的输入分组需要在输入端口排队，并等待 被调度通过交换结构；</li>
</ul>
<h3 id="4-2-2-交换结构"><a href="#4-2-2-交换结构" class="headerlink" title="4.2.2 交换结构"></a>4.2.2 交换结构</h3><h4 id="三种交换技术"><a href="#三种交换技术" class="headerlink" title="三种交换技术"></a>三种交换技术</h4><blockquote>
<p>内存，总线，纵横</p>
</blockquote>
<ul>
<li>经内存交换<ul>
<li>传统计算机的设计方式，<strong>CPU</strong>对分组进行在内存的I/O操作；</li>
<li>现代内存交换：输入线路卡查找转发表，并将分组放入适当的内存存储位置，也就是输出端口的内存</li>
</ul>
</li>
<li>经总线交换<ul>
<li>通过共享总线将分组发送到输出端口<ul>
<li>输入端口为分组预先计划一个内部标签（首部），该标签用来标识输出端口</li>
<li>分组在总线上传送到输出端口</li>
<li>所有输出端口都会收到分组，只有与标签匹配的端口才将分组保存，然后标签在输出端口被去除</li>
</ul>
</li>
<li>一次只有一个分组可以跨越总线，路由器的交换带宽受到其总线速率的限制；</li>
</ul>
</li>
<li>经互联网络交换<ul>
<li>纵横式交换机是一种由2N条总线组成的互联网络；</li>
<li>连接N个输入端口和N个输出端口</li>
<li>垂直总线在交叉点和水平总线交叉，交叉点通过交换结构控制器能在任何时候开启和闭合；</li>
<li>对于来自不同输入需要达到不同输出端口的分组，纵横网络能够转发多个这样的分组；</li>
<li>对于进入相同总线的分组，还是需要排队等待；</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-输出端口"><a href="#4-2-3-输出端口" class="headerlink" title="4.2.3 输出端口"></a>4.2.3 输出端口</h3><ul>
<li>输出端口：取<strong>出存放在输出端口内存中的分组，并将其发送到输出链路上；</strong></li>
<li>选择和取出排队分组进行传输，执行链路层和物理层传输功能；</li>
</ul>
<h3 id="4-2-4-排队"><a href="#4-2-4-排队" class="headerlink" title="4.2.4 排队"></a>4.2.4 排队</h3><ul>
<li>输入和输出端口处都会形成分组排队</li>
<li>排队位置和程度：取决于流量负载、交换结构的相对速率、线路速率；</li>
<li>随着队列增长，路由器的缓存空间最终耗尽，新到达的分组将会出现<strong>丢包</strong> </li>
</ul>
<h3 id="4-2-5分组调度程序"><a href="#4-2-5分组调度程序" class="headerlink" title="4.2.5分组调度程序"></a>4.2.5分组调度程序</h3><ul>
<li>服务原则<ul>
<li>先来先服务 FCFS</li>
<li>优先权排队</li>
<li>循环和加权公平排队</li>
</ul>
</li>
</ul>
<h2 id="4-3-网际协议：-转发和编址"><a href="#4-3-网际协议：-转发和编址" class="headerlink" title="4.3 网际协议： 转发和编址"></a>4.3 网际协议： 转发和编址</h2><h3 id="4-3-1-IPv4数据报格式"><a href="#4-3-1-IPv4数据报格式" class="headerlink" title="4.3.1 IPv4数据报格式"></a>4.3.1 IPv4数据报格式</h3><ul>
<li>网络层的分组： <strong>数据报</strong> datagram</li>
<li>IPv4 数据报格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">IPv4数据报格式 一行32bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 | 首部长度 | 服务类型 | 数据报长度（字节）</td>
</tr>
<tr>
<td align="center">16比特标识 | 标志 | 13比特片偏移</td>
</tr>
<tr>
<td align="center">寿命 | 上层协议 | 首部检验和</td>
</tr>
<tr>
<td align="center">32比特源IP地址</td>
</tr>
<tr>
<td align="center">32比特目的IP地址</td>
</tr>
<tr>
<td align="center">选项（如果有的话）</td>
</tr>
<tr>
<td align="center">数据</td>
</tr>
</tbody></table>
<ul>
<li><p>版本：4个比特，IP协议版本</p>
</li>
<li><p>首部长度：4个比特，用来确定数据部分从哪里开始，不包含选项的情况，数据报首部为20字节</p>
</li>
<li><p>服务类型：TOS，实时数据报，非实时数据报，用来确定数据报的优先级</p>
</li>
<li><p>数据报长度：包括首部的IP数据报的总长度，16比特，最大理论长度2^ 16,65535</p>
</li>
<li><p>标识、标志、片偏移：IP分片</p>
</li>
<li><p>寿命：Time-To-Live TTL，每经过一个路由器，该值减1，TTl为0时丢弃，取保数据报不会永远在路由选择环路中循环转发；</p>
</li>
<li><p>协议：上层协议，6为TCP，17为UDP</p>
<p>&gt; 协议号：网络层与运输层绑定到一起的粘合剂 &gt; &gt; 端口号：运输层与应用层绑定到一起的粘合剂 &gt; &gt; 链路层帧</p>
</li>
<li><p>首部检验和：checksum，检验收到的ip数据报中的比特错误；</p>
<ul>
<li>只对首部做检验</li>
<li>计算方式：将首部中的每2个字节，也就是16个比特相加在进行反码运算；</li>
<li>每个路由器都要对每个收到的IP数据报进行首部检验和的计算，检测出差错就丢弃，因为TTL每次都会减1，所有路由器会每次重新计算检验和并放置到数据报的检验和位置</li>
<li>IP协议和TCP/UDP协议都需要进行检验和<ol>
<li>IP数据报只是对数据报的首部进行检验</li>
<li>TCP/UDP是对整个报文段进行检验，而且报文段就是IP数据报的数据部分</li>
<li>TCP原则上可以运行在其他协议上 如ATM</li>
</ol>
</li>
</ul>
</li>
<li><p>源和目的IP地址</p>
</li>
<li><p>选项：允许IP首部被扩展，很少使用，已经在IPv6中去除</p>
</li>
<li><p>数据：有效载荷，运输层报文段，或者ICMP报文</p>
</li>
</ul>
<blockquote>
<p>对于无 “选项” 的IP数据报首部总长度为20个字节；</p>
<p>如果IP数据报承载了TCP报文段，则数据报承载了20字节的IP数据报首部，20字节的运输层TCP报文段的首部，及应用层报文；</p>
</blockquote>
<h3 id="4-3-2-IP数据报分片"><a href="#4-3-2-IP数据报分片" class="headerlink" title="4.3.2 IP数据报分片"></a>4.3.2 IP数据报分片</h3><ul>
<li>对于不同的链路层协议，其能承载的网路层数据报的长度不同，以太网协议能承载1500字节的数据，某些广域网链路帧可承受不超过576字节的数据；</li>
<li><strong>“最大传送单元”</strong>：Maximum Transmission Unit, MTU, 一个链路层数据帧能够承载的最大数据量；</li>
<li>发送方和接收方的路径上的每段链路可能使用不同的链路层协议，每种协议都可能由不同的MTU；</li>
<li>对于过大的IP数据报，超过链路MTU的情况下，需要对IP数据报做分片；单独的链路帧将封装这些较小的IP数据报；然后将链路帧发送到链路上，每个较小的数据报为<strong>“片”</strong> fragment</li>
<li>分片方法：<ul>
<li>发送端该数据报设置源目的地址的同时，会贴上“标识”，为每个发送的数据报标识加1；</li>
<li>路由器需要对数据报分片时，每个数据报都会由源目的地址和自己的标识号；</li>
<li>目的主机通过标识号确定那些数据报（片）是同一个大的数据报；</li>
<li>最后一片的标志比特为0，其他片的标志比特为1，目的是让目的端确定已经收到了所有的片；</li>
<li>偏移字段用来指定该片在数据报中的位置，目的端按照顺序组装，同时也可以确定数据报是否有片丢失；</li>
</ul>
</li>
<li>目的端，只有当IP层已经完成了重构初始IP数据报时，有效载荷才会被传递给运输层；如果一片或者多片没有到达目的地，则不完整的数据报会被丢弃，不会交给运输层；TCP超时重传、选择重传、快速重传，<strong>IPv4将重新组装工作放在端系统中</strong></li>
</ul>
<h3 id="4-4-3-IPv4-编址"><a href="#4-4-3-IPv4-编址" class="headerlink" title="4.4.3 IPv4 编址"></a>4.4.3 IPv4 编址</h3><ul>
<li><p>主机与路由器连入网络</p>
<ul>
<li>一台主机通常只有一条链路连接到网络；</li>
<li>主机和物理链路之间的边界叫做<strong>接口 interface</strong>；</li>
<li>一个IP地址与一个接口相关联，不与主机及路由器相关联；</li>
<li>IP地址，<strong>32bit</strong>，点分十进制法书写；</li>
<li>因特网处NAT之外的每台主机、路由器的接口都有一个唯一的IP地址；</li>
<li>IP地址的一部分由连接的子网来决定；</li>
<li>例子：<ul>
<li>3台主机与1台路由器相连，4个接口的ip地址的前24bit相同；</li>
<li>3个主机的接口与一个路由器的接口形成一个子网（subnet）；</li>
<li>IP编址为这个子网分配一个地址，<strong>”/24“</strong>，为子网掩码（network mask），这表示32bit中最左侧的24比特定义了子网地址；</li>
<li>任何需要连入该子网的主机，ip地址都需要具有与前24bit子网地址相同的形式；</li>
<li>确定网络中子网的方法：<ul>
<li>分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口“端接”隔离的网络端点，隔离的网络中的每一个都是一个子网（subnet）</li>
</ul>
</li>
<li>一个具有“多个以太网段”和点对点链路的组织将具有多个子网；</li>
</ul>
</li>
</ul>
</li>
<li><p>地址分配策略：</p>
<ul>
<li>无类别域间路由选择（Classless Interdomain Routing，CIDR）</li>
<li>CIDR将子网地址划分为两部分，表示为a.b.c.d/x，其中x表示地址的第一部分的比特数；</li>
<li>a.b.c.d/x 的地址的x 最高比特构成了ip地址的网络部分，地址的前缀（prefix）（网络前缀）；</li>
<li>路由选择协议，转发只考虑该网络前面的前缀比特x，这就减少了路由器中转发表的长度；</li>
<li>实践原则：<ul>
<li>地址聚合 address aggregation：使用单个网络前缀通告多个网络或多个子网的能力</li>
<li>也称作 路由聚合 route aggregation，路由摘要 route summarization</li>
</ul>
</li>
<li>一个地址剩余的32-x比特用来区分内部设备；只有内部设备连接的内部路由器在转发分组时，才会考虑这些剩余的bit；低级的bit可能有另外的子网结构；<ul>
<li>例如：a.b.c.d/21中的前21个比特表示当前组织的网络前缀，a.b.c.d/24表示组织内部的子网；</li>
</ul>
</li>
<li>分类编址，旧方式</li>
<li>ip广播地址 255.255.255.255，当一台主机向广播目的地址发送数据报时，该报文会交付给同一子网内所有的主机；</li>
</ul>
</li>
<li><p>获取地址</p>
<ul>
<li>从ISP获取，因特网名字和编号分配机构获取；（Internet Corporation for Assigned Names and Numbers，ICANN）</li>
</ul>
</li>
<li><p>DHCP 动态主机配置协议</p>
<ul>
<li>DHCP允许主机自动获取（被分配）IP地址，可以配置，在每次连接外部网络时都能获得相同的IP地址，或者被分配一个<strong>临时的IP地址</strong>（temporary IP address）；</li>
<li>DHCP还允许主机得知，子网掩码，第一跳路由器地址（默认网关），与本地DNS服务器地址</li>
<li>DHCP为 <strong>即插即用协议</strong></li>
<li>DHCP在主机加入或者 离开网络时，DHCP服务器会更新可用IP地址表；一台机器加入，则从当前可用地址池中分配任意一个地址；主机离开时，地址会回收到该地址池中；</li>
<li>客户-服务器协议，客户为新到达的主机，客户需要获取一个自身使用的IP地址和网络配置信息；如果该网络中没有DHCP服务器，则需要一个DHCP中继代理；</li>
<li>对于新到达的主机DHCP的四个步骤：<ol>
<li>DHCP服务器发现，DHCP发现报文（DHCP discover message)，客户使用UDP的DHCP发现报文，以广播地址255.255.255.255作为目的地址，本机源地址0.0.0.0作为源地址，67作为目标端口，DHCP客户将IP数据报传递给链路层，链路层将帧广播到所有与该子网连接的子网；</li>
<li>DHCP服务器提供，DHCP服务器收到报文后，用DHCP提供报文（DHCP offer message）向客户做出响应；仍然使用广播地址<ol>
<li>提供报文包括：发现报文的事务ID，向客户推荐的IP地址、网络掩码及IP地址租用期（address lease time）</li>
</ol>
</li>
<li>DHCP请求，客户从多个DHCP服务器中选择一个，并向服务器发送DHCP请求响应（DHCP request message）进行响应，回显配置参数；</li>
<li>DHCP ACK，服务器用DHCP ACK报文对DHCP请求报文进行确认响应；</li>
</ol>
</li>
<li>客户收到DHCP ACK之后，交互完成，客户可用在租用期之内使用分配的IP地址，如果超时后还希望继续使用，DHCP提供一种机制允许用户更新对地址的租用；</li>
</ul>
</li>
</ul>
<h3 id="4-3-4-网络地址转换NAT"><a href="#4-3-4-网络地址转换NAT" class="headerlink" title="4.3.4  网络地址转换NAT"></a>4.3.4  网络地址转换NAT</h3><ul>
<li><p>NAT<strong>“使能”</strong>路由器对于外部网络来说，就是一台具有单一ip的设备，所有离开这个NAT子网的数据报，都有同一个源地址IP，所有进入该网络的数据报都有同一个相同的目的IP；</p>
</li>
<li><p>本质：NAT使能路由器对外界<strong>隐藏了内部网络的细节</strong>；</p>
</li>
<li><p>在此网络内部，有独立的NAT-DHCP服务为内部的设备分配IP，路由器从ISP的DHCP服务获取外部IP；</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307193214279.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230307193214279"></p>
</li>
<li><p><strong>NAT转换表</strong> 如上图</p>
<ul>
<li><strong>表中包含了WAN端的IP地址和端口 及 映射的 LAN端 IP地址和端口</strong></li>
<li>对于本地子网要发送的数据报，NAT会将内部子网主机的IP地址及端口号，记录在转发表的LAN端，NAT路由器收到数据报后会生成一个新的源端口（选择当前任意一个不在转换表中的端口，支持超过60 000个并行的广域网IP地址连接），<strong>并将数据报中的端口改为新的源端口，IP地址改为NAT的接口的广域网IP地址</strong>，并将数据报发送到目的地址；目的主机无法感知数据报中的源IP和端口都经过NAT协议的改装；</li>
<li><strong>目的端响应报文到达NAT路由器时，路由器会使用数据报中的源IP地址和源端口检索出内部子网主机的ip和端口，并改写数据报的目的IP和目的端口，并向主机转发该数据报，当有多个内部主机去访问同一个服务器时，</strong>从返回的信息不足以区分响应应该转发到哪个内部主机。此时，需要NAT设备根据传输层信息或其他上层协议去区分不同的会话，并且可能要对上层协议的标识进行转换，比如TCP或UDP端口号。这样NAT网关就可以将不同的内部连接访问映射到同一公网IP的不同传输层端口，通过这种方式实现公网IP的复用和解复用。<h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3></li>
</ul>
</li>
</ul>
<p>由于32bit的IP地址空间即将耗尽而形成的一种新的网际协议</p>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul>
<li>IPv6数据报格式</li>
</ul>
<table>
<thead>
<tr>
<th align="center">32bit一行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本 | 流量类型 | 流标签</td>
</tr>
<tr>
<td align="center">有效载荷长度 | 下一个首部 | 跳限制</td>
</tr>
<tr>
<td align="center">源地址 （128bit）</td>
</tr>
<tr>
<td align="center">目的地址 （128bit）</td>
</tr>
<tr>
<td align="center">数据</td>
</tr>
</tbody></table>
<ul>
<li>IPv6数据报格式变化<ul>
<li>扩大的地址容量<ul>
<li><strong>地址容量从32bit扩大到128比特</strong>，用16进制表示；</li>
<li>IPv6引入了<strong>任播地址</strong> （anycast address），用来将数据报交付给一组主机中的任意一个；</li>
</ul>
</li>
<li>简化的高效的40字节首部<ul>
<li>40字节定长首部，去除IPv4中的选项字段，允许更快的处理IP数据报</li>
</ul>
</li>
<li>流标签与优先级<ul>
<li>Flow：给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流；</li>
<li>音频和视频的传输就是一种“流”</li>
<li>流量类型字段，类似与IPv4中的TOS字段，用于给出一个流中某些数据报的优先级，用来指示某些应用程序的数据报比其他应用有更高的优先权；</li>
</ul>
</li>
</ul>
</li>
<li>IPv6数据报的结构更简单，更高效：<ul>
<li>版本：4bit，用于标识IP版本号； 6</li>
<li>流量类型：8bit，与IPv4中的TOS字段含义相似</li>
<li>流标签：20bit，用于标识一条数据报的流</li>
<li>有效载荷长度：16bit，给出IPv6数据报中定长40字节的首部后面的数据部分的比特数；</li>
<li>下一个首部：标识数据报中的内容需要交付给，哪个协议（TCP/UDP）与IPv4中的上层协议字段相同</li>
<li>跳限制：转发数据报的每台路由器对该值减1，当计数为0时，数据报被丢弃；用来限制数据报转发的路由器数量，防止数据报在环路中一直存在；</li>
<li>源地址和目的地址：128bit的源地址和目的地址字段</li>
<li>数据：有效载荷部分，包括运输层报文段的首部及应用层数据部分</li>
</ul>
</li>
<li>IPv4数据报中的字段在IPv6中已不存在<ul>
<li>分片/重新组装：IPv6不允许路由器对数据报进行分片和组装；分片和重新组装只在源和目的端执行；当路由器遇到较大分组无法转发到链路时（如超过1500个字节），直接将数据报丢弃，并向发送方回复“分组太大的” ICMP差错报文，ICMP报文也封装在IP数据报中；这样发送端收到ICMP报文后，将数据报在端系统出进行分片，从而加快了转发速率；</li>
<li>首部检验和：为了快速处理IP分组，将检验和去除，数据报中只有运输层报文端有首部检验和做检验；（IPv4的耗时主要体现在每个数据报都有自己的TTL，所有每个路由器进行检验后，还需要更新数据报中的检验和）</li>
<li>选项：选项字段去除，但是任然有选项的存在，如“下一个首部”字段指向的位置有可能时“选项”<h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4></li>
</ul>
</li>
</ul>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230307194809237.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230307194809237"></p>
<ul>
<li><p><strong>双栈</strong>， 有发送和接收IPv4，IPv6两种数据报的能力；</p>
</li>
<li><p>IPv6/IPv4节点必须有IPv6和IPv4两种地址；</p>
</li>
<li><p>IPv6数据报可以转换成IPv4数据报，但是会丢失IPv6数据报首部 一些在IPv4中无对应项的字段信息；</p>
</li>
<li><p>建隧道（tunneling），两个端系统进行IPv6数据报的交换，但是中间有一个IPv4的路由器，两个IPv6路由器之间的IPv4路由器的集合为 <strong>隧道</strong> Tunnel，借助隧道，在隧道发送端的IPv6结点，将IPv6数据报方到一个IPv4数据报的数据部分（有效载荷），该IPv4数据报通过中间路由被转发到隧道接收端，隧道接收到取出IPv6的数据，然后再为IPv6的数据报提供转发；</p>
</li>
</ul>
<h2 id="4-4-通用转发和SDN"><a href="#4-4-通用转发和SDN" class="headerlink" title="4.4 通用转发和SDN"></a>4.4 通用转发和SDN</h2><hr>
<p>下面是有关<strong>控制平面</strong>的东西</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308100610957.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230308100610957"></p>
<p>完成控制平面工作可能有两种做法：</p>
<ul>
<li>每路由器控制</li>
<li>逻辑集中控制：SDN采用了这种方式。</li>
</ul>
<h2 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h2><ul>
<li><p>可以用图来形式化的描述路由选择问题</p>
</li>
<li><p>分类</p>
<ul>
<li>集中式的路由选择算法<ul>
<li>该算法为“集中式的全局路由选择算法”</li>
<li>输入为所有节点的连通性及链路的费用，算法执行前需要<strong>获取全局的完整信息</strong>；</li>
<li>全局状态信息：<strong>链路状态算法</strong></li>
</ul>
</li>
<li>分散式路由选择算法<ul>
<li>以迭代、分布式的方式计算出最低费用路径，迭代的每个节点逐渐的计算到达某目的节点的最低费用；</li>
<li>距离向量算法DV</li>
</ul>
</li>
</ul>
</li>
<li><p>第二种广义分类</p>
<ul>
<li>静态路由选择算法（static routing algorithm），路由变化缓慢，通常人工调整</li>
<li>动态路由选择算法（dynamic routing algorithm），网络流量负载或者拓扑发生变化时改变路由选择路径；动态算法周期性的运行或者对拓扑变化直接响应</li>
</ul>
</li>
<li><p>第三种分类</p>
<ul>
<li>负载敏感算法（load-sensitive algorithm）</li>
<li>负载迟钝算法（load-insensitive algorithm），链路费用无法直接反应链路拥塞水平</li>
</ul>
</li>
</ul>
<h3 id="4-5-1-链路状态路由选择算法"><a href="#4-5-1-链路状态路由选择算法" class="headerlink" title="4.5.1 链路状态路由选择算法"></a>4.5.1 链路状态路由选择算法</h3><ul>
<li>链路状态算法中，网络拓扑和所以的链路状态都是已知的，并且作为LS算法的输入</li>
<li>实践中<ul>
<li>让每个结点向网络中所有其他结点广播链路状态分组</li>
<li>每个链路状态分组包含它所连接的链路的特征和费用 例如OSPF路由选择协议</li>
<li>链路状态广播算法 （link state broadcast）来完成</li>
<li>广播的结果是该网络中的所有结点都具有了与该网络等同的、完整的视图</li>
<li>每个结点都能运行LS算法计算出最低费用的集合</li>
</ul>
</li>
<li>Dijkstra算法<ul>
<li>Dijkstra算法计算源结点到网络中其他所有结点最低费用路径</li>
<li>此算法的最差时间复杂都为 O(n^2)，使用堆的数据结构，可以将时间复杂度降低到logn级别</li>
<li>当链路的费用依赖于当前链路所承载的流量时，链路状态选择算法会出现<strong>”振荡“</strong>，解决方式是确保路由器不同时运行LS算法；</li>
<li><a href="http://www.auswitz.top/2021/12/24/cnet-python-kruscul/">有关Dijstra的模拟实验</a></li>
</ul>
</li>
</ul>
<h3 id="4-5-2-距离向量路由选择算法"><a href="#4-5-2-距离向量路由选择算法" class="headerlink" title="4.5.2 距离向量路由选择算法"></a>4.5.2 距离向量路由选择算法</h3><ul>
<li><p><strong>距离向量 （Distance-Vector）</strong>算法</p>
<ul>
<li>迭代：获取信息和执行计算的过程需要持续到邻居之间无更多的信息交换为止</li>
<li>异步：不要求所有结点步骤一致的进行操作</li>
<li>分布式：每个结点要从一个或者多个直接相邻的结点获取信息，执行计算，将结果分发给邻居</li>
</ul>
<p>&gt; Bellman-Ford方程： 获取x到所有邻结点的费用，取从这些邻结点v到目标结点y的最小费用，则x到y的最小费用是所以邻居v的 <strong>c(x, v) + d v (y)</strong> 的最小值<br>$$<br>d_x (y) = min _v{ c(x, v) + d _v (y) }<br>$$</p>
</li>
<li><p><strong>DV算法的基本思想</strong></p>
<ul>
<li>每个结点x，对N中的所有结点，估计从自己到结点y的最低费用；</li>
<li>每个结点x，维护的信息如下：<ul>
<li>对于每个邻居v，从x到直接邻居v的费用 c(x, v)</li>
<li>结点x的距离向量，包含了x到N中所有目的地y的费用估计值</li>
<li>每个邻居的距离向量，x的每个邻居v</li>
</ul>
</li>
<li>算法思想的理解：<ul>
<li>该算法以分布式的方式，在网络中，每个结点接收相邻结点的距离向量副本，每次更新都会触发结点向响铃结点广播自己最新的距离向量；</li>
<li>每个结点根据B-F方程的思想不断更新自己缓存的到其他每个结点的最小距离；（最低费用）</li>
<li>当所有结点触发的更新完成后，也就是不再有异步更新时，该网络中的路由选择表趋于稳定；</li>
</ul>
</li>
<li>路由器需要周期性与相邻的路由器交换更新通告，动态建立路由表，以决定最短路径。</li>
</ul>
</li>
<li><p>伪代码：</p>
</li>
</ul>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gml">对每个结点<span class="hljs-symbol">x</span>进行如下操作：<br>    初始化：<br>        遍历所有网络中的所有目的地<span class="hljs-symbol">y</span>：<br>            估计 <span class="hljs-symbol">x</span> 的距离向量。如果是非邻接结点，那么距离为∞。<br>        遍历每个邻接结点 w：<br>            邻接结点 w 的距离向量。初始估计，不准确的。<br>        遍历每个邻接结点 w:    <br>            发送本结点 <span class="hljs-symbol">x</span> 的距离向量到每个邻接结点 w。<br> <br>    <br>    循环：<br>        等待（知道存在链路状态变化或者收到其他结点的距离向量之后终止等待）<br>        <br>        遍历网络N中的每个结点 <span class="hljs-symbol">y</span>：<br>            依照bellman-ford方程更新本地 <span class="hljs-symbol">x</span> 距离向量<br> <br>        如果 <span class="hljs-symbol">x</span> 的距离向量存在变化<br>            发送 <span class="hljs-symbol">x</span> 的距离向量给每一个邻居结点。<br></code></pre></td></tr></table></figure>
<ul>
<li>在该分布式、异步的算法中，每个结点不时的向它的每个邻居发送它的距离向量副本，当结点x从它的任意一个邻居v接收到新的距离向量，保持v的距离向量，然后使用Bellman-Ford方程更新他自己的距离向量，对每个节点；结点x的距离向量更新后，向每个邻居发送更新后的向量；最终结果会收敛到最低费用路径；</li>
</ul>
<blockquote>
<p>Dijkstra算法，LS算法是全局的，在运行之前需要先获取整改网络的完整信息</p>
<p>DV算法是分布式和异步的，每个结点具有的信息是他到直接相邻结点的链路费用，和它收到的这些邻居发给它的信息；</p>
<p>DV算法的实践： RIP、BGP、ISO IDRP、Novell IPX</p>
</blockquote>
<ul>
<li>从邻居接收更新的距离向量、重新计算<strong>路由选择表</strong> 和通知邻居到目的地的最低费用路径的费用已经发送变化，这个过程会持续下去，直到无更新报文发送为止；这时算法进入等待状态，直到再次有线路费用变化触发算法；</li>
</ul>
<h5 id="1-距离向量算法：链路费用改变与链路故障"><a href="#1-距离向量算法：链路费用改变与链路故障" class="headerlink" title="1. 距离向量算法：链路费用改变与链路故障"></a>1. 距离向量算法：链路费用改变与链路故障</h5><ul>
<li><p>在链路费用变化的过程中，如果某个结点接受了邻居结点的信息后，路由选择表并没有更新，则该结点不再向其邻居结点发送信息；</p>
</li>
<li><p><strong>路由选择环路 routing loop</strong></p>
<ul>
<li><p>分组将在两个结点之间不停的转发</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308104014621.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230308104014621"></p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308103959246.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230308103959246"></p>
</li>
<li><p>无穷级数问题</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-距离向量算法：增加毒性逆转"><a href="#2-距离向量算法：增加毒性逆转" class="headerlink" title="2. 距离向量算法：增加毒性逆转"></a>2. 距离向量算法：增加毒性逆转</h5><ul>
<li><strong>毒性逆转 （poisoned reverse）</strong>，可以避免路由环路</li>
<li>如上图5.7的实现方法：<strong>如果z通过y到达x，那么这段z将通告这段z到x的长度为∞</strong></li>
<li>无法解决3个或者更多系欸但的环路问题</li>
</ul>
<h5 id="3-LS与DB路由选择算法的比较"><a href="#3-LS与DB路由选择算法的比较" class="headerlink" title="3. LS与DB路由选择算法的比较"></a>3. LS与DB路由选择算法的比较</h5><ul>
<li><p>DV和LS算法采用<strong>互补</strong>的方法来解决路由选择计算问题；</p>
</li>
<li><p>比较 N为结点集合（路由器） E是边（链路）集合</p>
<ul>
<li><p>报文复杂性</p>
<ul>
<li>DV算法要求每次迭代时，在两个直接相邻的结点之间交换报文；当链路费用发生变化时，DV算法仅在新的链路费用，导致与该链路相连的结点的最低费用改变时，才会向其他相邻结点传播费用信息，如果不在发生改变则不会在向相邻结点发送；</li>
</ul>
</li>
<li><p>收敛速度</p>
<ul>
<li>DV算法收敛较慢，而且遇到路由选择环路时，会遇到无穷计数的问题；</li>
</ul>
</li>
<li><p>健壮性</p>
<ul>
<li>LS：一个结点可以会损坏或者丢弃它收到的LS广播分组，但是LS结点只计算自己的转发表，每个结点各自接收广播分组，各自进行计算，提供了一定程度的健壮性；</li>
<li>DV算法：一个结点如果产生了错误的链路费用，会通知它所有的相邻结点，这个错误会一直扩散到整个网络的所有路由器上；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-4-层次路由选择"><a href="#4-5-4-层次路由选择" class="headerlink" title="4.5.4 层次路由选择"></a>4.5.4 层次路由选择</h3><ul>
<li><p>实践和路由选择算法模型</p>
<ul>
<li>规模，当前的因特网上路由器需要巨大容量的内存存储路由选择信息；路由器的LS广播的开销会导致没有剩余的带宽用来发送数据分组，大量路由器中算法将永远无法收敛；</li>
<li>管理自治，网络需要按照意愿进行管理，还需要和外部其他网络连接；</li>
</ul>
</li>
<li><p>自治系统 Autonomous System AS</p>
<ul>
<li><p>每个AS由一组通常处于相同管理控制下的路由器组成</p>
</li>
<li><p>相同的AS中的路由器全都运行的同样的路由选择算法（如一种LS或一种DV）,且拥有彼此信息；</p>
</li>
<li><p>在一个自治系统内运的路由选择算法：<strong>自治系统内部路由选择协议 intra-autonomous system routing protocol</strong></p>
</li>
<li><p>在AS内部有<strong>一台或者多台</strong>路由器 <strong>”网关路由器 gateway router“</strong>，负责向本AS之外的目的地转发分组；</p>
</li>
<li><p>源AS只有一台网关路由器，且只有一条通向外部AS的链路时，分组会直接通过该链路传输；</p>
</li>
<li><p>自治系统之间的路由选择协议（inter-autonomous system routing protocol），AS间路由选择协议</p>
<p>BGP4</p>
<ul>
<li>从AS间协议知道经过多个网关可达子网x</li>
<li>使用来自AS内部协议的路由选择信息，以决定到每个网关的 <strong>最低费用路径</strong> 的费用</li>
<li>热土豆路由选择（hot potato routing），选择具有最低费用的网关</li>
<li>从转发表确定通向最低费用网关的接口I，将（x，I）项田间道转发表中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-6-因特网中自治系统内部的路由选择：OSPF"><a href="#4-6-因特网中自治系统内部的路由选择：OSPF" class="headerlink" title="4.6 因特网中自治系统内部的路由选择：OSPF"></a>4.6 因特网中自治系统内部的路由选择：OSPF</h2><blockquote>
<p>一个AS是一个处于相同的管理与技术控制下的路由器集合，在AS之间都运行相同的路由选择协议；每个AS通常又都包含多个子网；</p>
</blockquote>
<ul>
<li><p>OSPF：<strong>开放最短路优先</strong></p>
</li>
<li><p>OSPF核心：</p>
<ul>
<li>一个使用洪泛链路状态信息的链路状态协议</li>
<li>一个Dijkstra最低费用路径算法</li>
<li>使用OSPF，<strong>一台路由器构建了一副关于整个自治系统的完整拓扑图，每台路由器路由器运行Dijkstra最短路径算法，以确定一个以自身为根节点的到所有子网的最短路径数，链路状态信息是由网络管理员配置的；</strong></li>
<li>OSPF提供机制，为“给定链路权值集合”确定最低费用路劲路由选择</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>OSPF，路由器向自治系统内所有其他路由器广播路由选择信息；</li>
<li>当一条链路发生变化，路由器就会广播链路状态信息，当链路状态未发生变化，路由器会周期性的广播链路状态信息（至少每30min）</li>
<li>OSPF报文，由IP协议承载，上层协议值为<strong>89</strong>，OSPF协议自己实现可靠报文传输、链路状态广播等功能</li>
<li>OSPF要检查链路正在运行，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库</li>
</ul>
</li>
<li><p>OSPF的优点</p>
<ul>
<li><strong>安全</strong>；能够鉴别OSPF路由器之间的交换；使用鉴别，只有受到信任的路由器能参与AS内的OSPF协议；MD5散列值计算；</li>
<li><strong>多条相同费用的路径</strong>；出现多条相同费用路径时，OSPF允许使用多条路径；</li>
<li><strong>对单播和多播路由选择的综合支持</strong>；多播：使用现有的OSPF链路数据，为现有的OSPF链路状态广播机制增加了新型的链路状态通告；</li>
<li><strong>支持在单个路由选择域内的层次结构</strong>；<strong>具有按层次结构构建一个自治系统的能力</strong></li>
</ul>
</li>
</ul>
<h2 id="4-7-ISP间的路由选择：BGP"><a href="#4-7-ISP间的路由选择：BGP" class="headerlink" title="4.7 ISP间的路由选择：BGP"></a>4.7 ISP间的路由选择：BGP</h2><ul>
<li><p>OSPF 来决定位于相同AS内部的源和目的之间的路由选择路径；跨越多个AS的源和目的之间的路由选择，<strong>边界网络协议 Border Gateway Protocol, BGP</strong></p>
</li>
<li><p>BGP协议是所有因特网协议中最重要的协议，唯一的竞争者就是IP协议，它将数以千计的ISP粘结在一起。</p>
</li>
<li><p>工作手段</p>
<ul>
<li>从相邻AS处获得子网可达信息</li>
<li>向本AS内部的所有路由器传播这些可达信息</li>
<li>基于可达性信息和AS策略，决定到达子网的 “好” 路由</li>
</ul>
</li>
</ul>
<h3 id="4-7-1-BGP作用"><a href="#4-7-1-BGP作用" class="headerlink" title="4.7.1 BGP作用"></a>4.7.1 BGP作用</h3><p>对于位于AS目的地而言，路由转发表决定，而对于外部，正是由BGP协议发挥作用，提供了以下手段：</p>
<ol>
<li><strong>从邻居AS获得前缀的可达性信息</strong></li>
<li><strong>确定到该前缀的“最好的”路由</strong></li>
</ol>
<h3 id="4-7-2-通告BGP路由信息"><a href="#4-7-2-通告BGP路由信息" class="headerlink" title="4.7.2 通告BGP路由信息"></a>4.7.2 通告BGP路由信息</h3><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230308110231533.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230308110231533"></p>
<p>如图所示，简单的网络具有AS1、AS2、AS3。AS的边缘路由器是网关路由器，如1c</p>
<ul>
<li><p>怎么向所有路由器通告x的存在呢？</p>
</li>
<li><p>过程：<strong>AS3向AS2发送一个BGP报文，告知x存在且位于AS3中，将该报文表示为AS3 x，然后AS2向AS1发送一个BGP报文，告知x的存在并且先通过AS2到达AS3然后找到x，将该报文表示为AS2 AS3 x，但是有一点细节需要注意，AS之内的BGP报文叫iBGP，AS之间的BGP报文叫eBGP。</strong></p>
</li>
</ul>
<h3 id="4-7-3-确定最好的路由"><a href="#4-7-3-确定最好的路由" class="headerlink" title="4.7.3 确定最好的路由"></a>4.7.3 确定最好的路由</h3><h4 id="热土豆路由器选择"><a href="#热土豆路由器选择" class="headerlink" title="热土豆路由器选择"></a>热土豆路由器选择</h4><ul>
<li>过程：<strong>对于AS内部的路由器发送分组，考虑的是尽可能快的将分组送出其AS，而不担心AS外部到目的地余下的开销。</strong></li>
</ul>
<h4 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h4><p>实践中，BGP使用了一种比热土豆更好的算法，如果相同前缀的有两条或者多条路由，则顺序的调用以下消除规则：</p>
<ol>
<li><strong>路由被指派一个本地偏好，优先被选择</strong></li>
<li><strong>选出具有最短AS-PATH的路由，如果该规则是选择的唯一规则，则BGP将使用距离向量算法决定路径，其中距离测度是AS的跳数而不是路由器的跳数</strong></li>
<li><strong>从余下的路由使用热土豆算法</strong></li>
<li>如果仍然有多条路由，则使用BGP的标识符来选择路由</li>
</ol>
<h3 id="4-7-4-IP任播"><a href="#4-7-4-IP任播" class="headerlink" title="4.7.4 IP任播"></a>4.7.4 IP任播</h3><p>BGP除了被用于选择路由，还被用于IP任播，但是实践中并不用</p>
<ul>
<li>过程：<strong>例如在CDN实践中，在路由任播阶段，CDN公司为他的多台服务器指派相同的IP地址，并使用标准的BGP来通告，BGP路由器收到同一个IP的多个路由的时候，理解为相同物理位置不同的路径，因此客户向CDN-IP请求内容的时候，BGP就向最近的服务器转发分组。</strong></li>
</ul>
<h1 id="5-链路层和局域网"><a href="#5-链路层和局域网" class="headerlink" title="5.链路层和局域网"></a>5.链路层和局域网</h1><h2 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h2><p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-aus-image-20230228154622539.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif"></p>
<ul>
<li><p>节点：运行链路层协议的任何设备</p>
</li>
<li><p>链路：物理通道</p>
</li>
<li><p>数据链路：逻辑通道</p>
</li>
<li><p>帧：链路层分组，封装网络层数据报</p>
</li>
<li><p>作用：在物理层服务基础上向网络层提供服务，将物理层提供的可能出错的链接改造成一条无差错的链接</p>
</li>
<li><p>功能：成帧、链路接入、可靠交付、差错检测和纠错</p>
</li>
</ul>
<h2 id="5-2封装成帧及透明传输"><a href="#5-2封装成帧及透明传输" class="headerlink" title="5.2封装成帧及透明传输"></a>5.2封装成帧及透明传输</h2><h2 id="5-3差错控制及纠正技术"><a href="#5-3差错控制及纠正技术" class="headerlink" title="5.3差错控制及纠正技术"></a>5.3差错控制及纠正技术</h2><ul>
<li><p>差错：位错、帧错</p>
</li>
<li><p>差错控制：检错编码和纠错编码</p>
<ul>
<li><p>检错编码：奇偶校验码和循环冗余码CRC</p>
<ul>
<li><p>奇偶校验码</p>
</li>
<li><p>CRC：<strong>异或计算（同0异1）</strong></p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230228164052122.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230228164052122"></p>
</li>
</ul>
</li>
<li><p>纠错编码：海明码</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-4流量控制与可靠传输机制"><a href="#5-4流量控制与可靠传输机制" class="headerlink" title="5.4流量控制与可靠传输机制"></a>5.4流量控制与可靠传输机制</h2><h2 id="5-5多路访问链路和协议"><a href="#5-5多路访问链路和协议" class="headerlink" title="5.5多路访问链路和协议"></a>5.5多路访问链路和协议</h2><h3 id="5-5-1信道划分协议"><a href="#5-5-1信道划分协议" class="headerlink" title="5.5.1信道划分协议"></a>5.5.1信道划分协议</h3><ul>
<li><p>TDM时分多路复用</p>
</li>
<li><p>FDM频分多路复用</p>
</li>
<li><p>CDMA码分多址：类似于时隙和频隙的一种划分方式，仅作了解</p>
</li>
</ul>
<h3 id="5-5-2随机接入协议"><a href="#5-5-2随机接入协议" class="headerlink" title="5.5.2随机接入协议"></a>5.5.2随机接入协议</h3><ul>
<li><p>时隙ALOHA：ALOHA的改进版，把时间分为相同大小的时间片SLOT，不监听信道、按时间槽发送、随机重发（时间片开始）、想发就发，碰撞概率仍然很大</p>
</li>
<li><p>ALOHA：不监听信道、不按时间槽发送、随机重发、想发就发，碰撞概率很大</p>
</li>
<li><p>CSMA载波监听：先听再发，几种方式如下：</p>
<ul>
<li>1坚持：空闲时可能有多个计算机同时发送，可能导致冲突</li>
<li>非坚持：如果监听到忙，就放弃监听，等待随机时间后再监听</li>
<li>p坚持：和1坚持的区别就是发送数据的概率，产生冲突的概率小一点</li>
</ul>
</li>
<li><p>CSMA/CD：碰撞检测，先听再发，边听边发，冲突停发，随机重发。最小帧长的规定。</p>
<ul>
<li>如何重发：截断二进制指数退避算法 P300：第一次在{0，1}中等概率选择一个，第二次在{0，1，2，3}中等概率选择一个… …第十次在{0，1，……，1023}中等概率选择一个。</li>
</ul>
</li>
</ul>
<h3 id="5-5-3轮流协议"><a href="#5-5-3轮流协议" class="headerlink" title="5.5.3轮流协议"></a>5.5.3轮流协议</h3><ul>
<li>轮询协议</li>
<li>令牌传递协议<h2 id="5-4交换局域网"><a href="#5-4交换局域网" class="headerlink" title="5.4交换局域网"></a>5.4交换局域网</h2></li>
</ul>
<h3 id="5-4-1链路层寻址和ARP"><a href="#5-4-1链路层寻址和ARP" class="headerlink" title="5.4.1链路层寻址和ARP"></a>5.4.1链路层寻址和ARP</h3><ul>
<li><p>发送数据报到子网以内</p>
<ul>
<li>局域网，不使用IP地址寻址，通过链路层地址MAC寻址</li>
<li>如果ARP表中有对应的项，那么正常发送即可。</li>
<li><strong>如果ARP表中没有对应IP的MAC地址，那么发送方向他的适配器传输一个ARP查询分组，指示适配器用MAC广播地址将这个分组发送出去，然后局域网中其他设备检查自己的ARP表，将与之匹配的ARP项返回给查询主机，查询主机再进行后续的操作。</strong></li>
</ul>
</li>
<li><p>发送数据报到子网以外</p>
<ul>
<li><strong>子网1向子网2发送数据报，子网1中的设备向子网1中的设备查询，子网1中的路由器发现该地址是向它寻址的，因此把这个帧传给路由器的网络层。路由器通过查询转发表将该帧转发到子网2的路由器接口，然后该接口把包传递给他的适配器，再通过查询ARP来查询到MAC地址封装到一个新的帧，最后将帧转发到目的地。</strong></li>
</ul>
</li>
</ul>
<h3 id="5-4-2以太网"><a href="#5-4-2以太网" class="headerlink" title="5.4.2以太网"></a>5.4.2以太网</h3><p>以太网是目前最流行的有线局域网技术</p>
<ul>
<li><p>以太网帧结构</p>
<ul>
<li>前同步码|目的地址|源地址|类型|数据| |CRC<ul>
<li>数据：这个字段承载了IP数据报</li>
<li>目的地址：包含目的适配器的MAC地址</li>
<li>源地址：包含了源MAC地址</li>
</ul>
</li>
</ul>
</li>
<li><p>以太网技术</p>
<ul>
<li><p>以太网向网络层提供不可靠服务：帧没有通过CRC校验时只是舍弃该帧</p>
</li>
<li><p>以太网向网络层提供无连接服务：不事先握手</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-4-3链路层交换机"><a href="#5-4-3链路层交换机" class="headerlink" title="5.4.3链路层交换机"></a>5.4.3链路层交换机</h3><ul>
<li><p>交换机转发和过滤</p>
<ul>
<li>过滤：决定一个帧是否转发和是否丢弃 </li>
<li>转发：决定一个帧被导向哪个接口</li>
<li>交换机的转发和过滤借助于交换机表</li>
</ul>
</li>
<li><p>自学习</p>
<ul>
<li><p>交换机表是自动、动态、自治的建立的，即插即用设备</p>
</li>
<li><p>交换机表初始为空</p>
</li>
<li><p>对于每个接口接收到的入帧，交换机将其存储</p>
</li>
<li><p>老化器：一段时间，该地址不活跃，交换机就将其删除</p>
</li>
</ul>
</li>
<li><p>链路层交换机的性质 p315</p>
<ul>
<li>消除碰撞</li>
<li>异质的链路：交换机将链路隔离，因此局域网中不同的链路能一不一样的速度、介质存在。</li>
<li>管理：交换机可以为网络管理提供便捷</li>
</ul>
</li>
<li><p>交换机和路由器的比较</p>
<ul>
<li><p>交换机基于MAC地址转发（第二层）、路由器基于IP地址转发（第三层），现代交换机两种都有。</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>交换机</td>
<td>1、即插即用。2、相对高的分组过滤和转发速率。</td>
<td>为了防止广播帧的循环，交换网络的活跃拓扑严格限制成一棵树，但是交换机对这个没有限制，有可能导致以太网的崩溃。</td>
</tr>
<tr>
<td>路由器</td>
<td>1、一般分组不会被循环。允许了非常丰富的拓扑结构来构建因特网。2、对第二层的广播风暴构建了防火墙。</td>
<td>处理时间比交换机更长</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="5-4-4虚拟局域网VLAN"><a href="#5-4-4虚拟局域网VLAN" class="headerlink" title="5.4.4虚拟局域网VLAN"></a>5.4.4虚拟局域网VLAN</h3><p>在一个单一的物理局域网中定义多个虚拟局域网，支持VLAN的交换机的端口被管理员划分为组</p>
<p><img src="https://pic-aus-1252275196.cos.ap-nanjing.myqcloud.com/img/aus-image-20230302151151787.png?imageMogr2/format/jpg/interlace/0/strip%7Cwatermark/2/text/YXg/font/c2ltZmFuZ-S7v-Wuiy50dGY/fontsize/18/fill/IzAwMDAwMA/dissolve/60/shadow/0/gravity/south/dx/0/dy/1" srcset="/img/loading.gif" alt="image-20230302151151787"></p>
<p>这些端口中的广播流量仅能到达该组中的其他端口</p>
<ul>
<li>怎么解决完全隔离带来的组与组之间传递的问题呢：VLAN干线连接</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Notebook/">Notebook</a>
                    
                      <a class="hover-with-bg" href="/categories/Notebook/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/25/CcNoteBook/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Notebook|CcNotebook||计算机组成原理笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/30/os1/">
                        <span class="hidden-mobile">【操作系统】|Linux 命令解释程序设计与实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "NWytlCMJI03CQOQYOFuI0nNx-gzGzoHsz",
          app_key: "dfBdcYBLVYgWf12l7QnVV3wC",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://www.auswitz.top" target="_blank" rel="nofollow noopener"><span>Aus</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/javascript" src="\js\snow.js"></script>
<script type="text/javascript" src="\js\click.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
